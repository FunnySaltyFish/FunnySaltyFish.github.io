<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FunnySaltyFish&#39;s Blog</title>
  
  <subtitle>FunnySaltyFish的小站</subtitle>
  <link href="https://blog.funnysaltyfish.fun/atom.xml" rel="self"/>
  
  <link href="https://blog.funnysaltyfish.fun/"/>
  <updated>2022-06-23T05:37:06.688Z</updated>
  <id>https://blog.funnysaltyfish.fun/</id>
  
  <author>
    <name>FunnySaltyFish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【杂谈】我用 Jetpack Compose 的这一年</title>
    <link href="https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-one-year/"/>
    <id>https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-one-year/</id>
    <published>2022-06-23T05:36:50.000Z</published>
    <updated>2022-06-23T05:37:06.688Z</updated>
    
    <content type="html"><![CDATA[<p>关于这篇文章，其实本来并没有什么写作计划。触发它诞生的事情是，今天早上，QQ空间给我推了这样一条消息：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/06/08/62a061b06cc63.png" alt="image-20220608164528747"></p><p>一年前的今天，我敲下了第一行的<code>Hello Android for Jetpack Compose</code>，而到今天，我的个人小项目 <a href="https://github.com/FunnySaltyFish/FunnyTranslation">译站</a> 早已全面转向 Jetpack Compose 。关于 Compose，我也写了几个简易的开源库、作了几篇小文章。所以今天，不妨来谈谈我接触 Compose 的这一年。</p><p><em>本文 <strong>不是技术文</strong> ，其中观点仅代表我个人。受限于本人技术水平，难免有误，还望您包容谅解</em></p><h3 id="初"><a href="#初" class="headerlink" title="初"></a>初</h3><p>我接触 Compose 的时间应该还算较早，虽然不是最早的一批，但也算是那时的少数（至少我以为）。彼时，Google 发布 <strong>beta</strong> 版本，尚且只有 <code>AS</code> 的 <code>Beta</code> 版本支持。为了体验，我将一直使用的<code>AS Stable</code>切成了<code>AS Beta</code>，用默认模板敲出了第一行代码。</p><p>我是一个对新技术很感兴趣的人，这可能也是我去学习 Compose 的原因。声明式UI的概念虽然相较<code>View</code>很新奇，但鉴于我接触过<code>Vue</code>和<code>Flutter</code>，所以也还能上手。</p><p>上手是可以上手，但奈何资料确实不多，尤其是中文的。对我来说，早期学习 Compose 的资料基本主要来自<code>Google官网 </code> 和 <code>Youtube</code> 。看着英文资料和视频，我逐渐学会了使用<code>Row</code>和<code>Column</code>，学会了要<code>remember</code>，学会了几种副作用的使用，学会了<code>animate*AsState</code> 和 <code>animateVisibility</code>……这段过程中，Youtuber <a href="https://www.youtube.com/c/PhilippLackner">Philipp Lackner</a> 的 <a href="https://www.youtube.com/watch?v=cDabx3SjuOY&list=PLQkwcJG4YTCSpJ2NLhDTHhi6XBNfk9WiC">Creating Your First Jetpack Compose App</a> 系列对我帮助很大，在此也遥远的表示感谢。</p><p>于是，在漫不经心地刷了些视频和文档后，我对 Compose 有了个大体的认识。于是我也想为中文资料做点力所能及的贡献，于是参考这个<a href="https://www.youtube.com/watch?v=ktOWiLx83bQ&list=PLgCYzUzKIBE_I0_tU5TvkfQpnmrP_9XV8&index=20">视频</a>和当时的官方教程，写了第一篇关于<code>Compose</code>的文章</p><ul><li>2021/07/29  <a href="https://juejin.cn/post/6990203393964769317">Jetpack Compose异步加载图片的实现 - 掘金 (juejin.cn)</a></li></ul><p>这篇文章的内容其实现在已经过时了，但在当时，<code>Compose</code>中文资料不多的情况下，它的搜索指数居然出乎意料的高。现在你搜索关键词<code>Jetpack Compose 加载图片</code>，可能在前几个结果中还能看到它。</p><p>写了文章之后，过了几天，我又感觉除了文章外好像没这方面的中文视频。于是我开了个<code>New App</code>，尝试录了几个视频介绍一些简单概念</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/06/08/62a0690128c40.png" alt="image-20220608171648685"></p><p>录了三个之后我鸽了，好吧，这视频的质量实在是不咋滴。没得设备和技术，而且录视频也是个技术活。但是既然学了，肯定要用啊。于是，我把目光转向了我自己的小项目，译站。</p><h3 id="译站"><a href="#译站" class="headerlink" title="译站"></a>译站</h3><p>它是我2020年初写的一款简单的翻译小应用，最早是用<code>View</code>实现的。秉持着以用代学的想法，我开始了对这个应用的<code>Compose</code>化。</p><p>到九月份，我基本实现了它的主页面。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/06/08/62a06a4b9df85.png" alt="image-20220608172219346"></p><p><em>（忽略这粗犷的 commit ……）</em></p><p>其实这里要说明的是，Compose 的迁移其实并没那么困难。Android 官方提供了非常棒的工具，允许你在<code>View</code>项目中部分使用<code>Compose</code>、或者在<code>Compose</code>中部分使用<code>View</code>。如果你原先的架构合理，<code>View</code>和<code>Model</code>没有非常强的耦合，那么其实改造起来很容易。<code>LiveData</code>或者<code>Flow</code>都可以通过<code>.observeAsState</code>一键转换成可以在 Compose 中使用的 State（Compose 的 UI 由 State 驱动）。我这里之所以花了那么久，有两个原因：</p><ul><li>一是我正好在重构代码的全部逻辑，包括一些类的分离、一些流程的改变等。秉持着一不做二不休的想法，我选择了把页面全部用 Compose 重写（而不是只改变一部分），故而比较花时间</li><li>二是有一些很简单的效果实现起来并没有那么容易，尤其是在中文资料极度匮乏的情况下。出了问题或者想实现什么效果，除了翻官方的网站就是翻 <code>Github</code>，这也比较花时间。</li></ul><p>总之，在各种折腾下，译站的 Compose 版本也逐渐重构完成了，并在那之后均用<small>（准确来说除了悬浮窗和CodeView）</small> Compose 完成各种 UI 效果。</p><h3 id="不断学习与博客"><a href="#不断学习与博客" class="headerlink" title="不断学习与博客"></a>不断学习与博客</h3><p>其实对我个人来说，开始学习 Compose 的时候有一个很困惑的点：不知道学完基础之后该学啥了。一方面是资料确实不多，而且视频教程也都是围绕着基本控件之类的来讲；二是我自己没有很大的东西去细究 Compose 的实现。于是三天打鱼两天晒网的，在不断更新应用的间隙间，也偶尔地学习一些新东西。</p><p>这里很感谢的一份资料是 <a href="https://juejin.cn/user/1714893871911502">RugerMc</a> 大佬牵头做的 <a href="https://github.com/compose-museum/jetpack-compose-book">jetpack-compose-book: Jetpack Compose 基础教程，持续更新 </a> ，很详细的介绍了 Compose 各个方面的使用。对于现在<strong>卖课混杂、培训遍地、营销漫天</strong>的中文互联网社区环境来说，这样无私的技术分享、开源布道的精神真是说得上不多见了。我自己也为这个项目提了绵薄的几个PR。互联网技术的精神应当在于包容、共享、探索、钻研，至少我是这样觉得的。</p><p>这段时间，不少大佬们的博客也在惊艳着我，比如<a href="https://juejin.cn/user/668101431009496/posts">程序员江同学</a>、<a href="https://juejin.cn/user/3931509309842872">fundroid</a>、<a href="https://juejin.cn/user/3491704662136541">Petterp</a>、<a href="https://juejin.cn/user/4019470242152616">路很长OoO</a>等，在我学习 Compose 的路上，他们的文章给了我很大帮助，再次均表示感谢。</p><p>对我来说，尽管我是一个很懒的人，但我还是也尝试着写起了 Compose 相关的文章。一是助于自己提升，二是为中文资料做点绵薄贡献。一点点，到现在我也已经写了13篇<a href="https://juejin.cn/column/7024350372680433672">关于 Compose 的文章</a>了。或许不足为道，但若是有人看到，说，这个不错，对我有帮助，那便足够了。</p><p>其中我自己觉得比较好玩的是 <a href="https://juejin.cn/post/7103824524876972046">Jetpack Compose 自定义布局+物理引擎 = ？</a> 这一篇。在那里，我用 Compose 自定义布局实现了这样的效果</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2694fea1b14df7b49b4b789b7b7a2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="PhysicsLayout演示_.gif"></p><p>没有用，但很有趣。这个想法出现在我高三的时候，但是一直觉得会很难就一直不想做，直到前几天下定决心做了做。在巨人的肩膀上，花了两天就实现了。感觉也蛮有成就感的。如果您感兴趣，可以在<a href="https://github.com/FunnySaltyFish/JetpackComposePhysicsLayout">Github</a>查看完整源代码</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说点正题的话，就我个人而言，我觉得 Compose 开发有以下优劣：</p><p><strong>优</strong></p><ul><li>代码即 UI，灵活、迅捷 <em>（比如  for 循环创建几个控件，if 判断显不显示）</em></li><li>对各种需求高度、统一的封装  <em>（通过 <code>LocalXXX</code> 和 <code>rememberXXX</code> 获取和操作各种东西，动画、软键盘、状态栏…… ）</em></li><li>允许逐步迁移  <em>（ View 体系 和 Compose 体系可良好共存）</em></li><li>字面量热重载  <em>（对于类似于 大小、字符串 的修改可直接反映到 App 上）</em></li><li>快速的 UI 搭建，无需过多考虑嵌套</li></ul><p>但就目前来说，也有些问题</p><ul><li>部分硬需求尚不完善，比如还没有瀑布流布局等</li><li>性能（如 滑动列表）上较传统 View（如 RV）仍有差距</li><li>目前中文资料较为欠缺，部分需求实现需要自己摸索</li><li>精通难度大（ Compose 编译原理、性能优化等）</li></ul><p>如果你是一个希望尝试的同学，我个人推荐这些资料（它们是免费的，如果你想学付费的请自行寻找，我不卖课）：</p><ul><li> <a href="https://juejin.cn/user/1714893871911502">RugerMc</a> 大佬牵头做的 <a href="https://github.com/compose-museum/jetpack-compose-book">jetpack-compose-book: Jetpack Compose 基础教程，持续更新 </a></li><li>上面提到的各位大佬的博客</li><li>开源项目<ul><li>官方例子：<a href="https://github.com/android/compose-samples">android/compose-samples: Official Jetpack Compose samples. (github.com)</a></li><li>官方例子：<a href="https://github.com/android/nowinandroid">android/nowinandroid: A fully functional Android app built entirely with Kotlin and Jetpack Compose (github.com)</a></li><li>Compose 复现的 网易云音乐，很多常用效果里面都实现了。来自掘金的<a href="https://juejin.cn/user/1856402275178407">sskEvan</a>。<a href="https://github.com/sskEvan/NCMusic">sskEvan/NCMusic: Jetpack Compose仿写网易云音乐 (github.com)</a></li><li>译站，鄙人的小项目，属于毛遂自荐了：<a href="https://github.com/FunnySaltyFish/FunnyTranslation">FunnySaltyFish/FunnyTranslation: 基于Jetpack Compose开发的翻译软件，支持多引擎、插件化~</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于这篇文章，其实本来并没有什么写作计划。触发它诞生的事情是，今天早上，QQ空间给我推了这样一条消息：&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBA</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Jetpack Compose 中调试重组</title>
    <link href="https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-debug-recomposition/"/>
    <id>https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-debug-recomposition/</id>
    <published>2022-06-23T05:36:00.000Z</published>
    <updated>2022-06-23T05:36:32.667Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 Compose 相关的偏进阶文章，给出了一些可用于 Compose 调试的方法，并阐释了一些性能优化方面的小细节。</p><p>本文译自 <a href="https://www.jetpackcompose.app/articles/how-can-I-debug-recompositions-in-jetpack-compose">How can I debug recompositions in Jetpack Compose?</a></p><p>原作者：<a href="https://twitter.com/vinaygaba">https://twitter.com/vinaygaba</a></p><p>译：<a href="https://github.com/FunnySaltyFish">FunnySaltyFish</a></p><hr><p>自从 Jetpack Compose 的第一个稳定版本上线以来，已经过去了好几个月<em>（译注：本文写于2022年4月）</em>。多家公司已经使用了 Compose 来参与构建他们的 Android 应用程序，成千上万的 Android 工程师每天都在使用 Jetpack Compose 。</p><p>虽然已经有大量的文档可以帮助开发人员接受这种新的编程模式，但仍有这么个概念让许多人摸不着头脑。它就是<code>Recomposition</code>，Compose 赖以运作的基础。</p><blockquote><p>重组是在输入更改时再次调用可组合函数的过程。当函数的输入发生更改时，它便会发生。当 Compose 基于新输入进行重组时，它仅调用可能已更改的函数或 lambda，并跳过其余部分。通过跳过所有未更改参数的函数或 lambda，Compose 可以有效地进行重组。</p></blockquote><p>如果您不熟悉此主题，我将<a href="https://www.jetpackcompose.app/articles/donut-hole-skipping-in-jetpack-compose#recomposition">在本文中</a>详细介绍 <code>Recomposition</code>。对于大多数用例，除非传入的参数变了，否则我们不希望重新调用可组合函数（此处从简表示）。Compose 编译器在这方面也非常聪明，当它有足够的可用信息时（例如，所有原始值类型的参数在设计上都是<code>Stable</code>的），它会尽最大努力来做些对使用者无感的优化；当信息没那么多时，Compose 允许您通过使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Stable">@Stable</a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Immutable">@Immutable</a> 注解提供元数据，以帮助 Compose 编译器正确做出决定。</p><p>从理论上讲，这一切都是有道理的，但是，如果开发人员有办法了解他们的可组合函数是如何重组的，那将大有裨益。这类功能目前呼声很高，不过要使Android Studio 快捷地为您提供此信息，还有一吨的工作要做。如果你像我一样迫不及待，你可能也想知道在能正式上手工具前，要想在 Jetpack Compose 中调试重组，咱可以做些什么。毕竟嘛，重组在性能上起着重要作用——不必要的重组可能会导致 UI 卡顿。</p><h1 id="打日志"><a href="#打日志" class="headerlink" title="打日志"></a>打日志</h1><p>调试重组的最简单方法是使用良好的 log 语句来查看正在调用哪些可组合函数以及调用它们的频率。这感觉上很直白，但注意这个坑 ： 我们希望仅在发生重组时才触发这些日志语句。这听起来像是 <code>SideEffect</code> 的用武之地。<a href="https://developer.android.com/jetpack/compose/side-effects#sideeffect-publish">SideEffect </a>是一个可组合的函数，每当成功的 Composition/ Recomposition 后便会被重新调用。<a href="https://www.jetpackcompose.app/articles/how-can-I-debug-recompositions-in-jetpack-compose">Sean McQuillan</a> 编写了如下代码片段，您可以使用它来调试您的重组。这只是一个框架，您可以根据需要进行调整。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ref</span></span>(<span class="keyword">var</span> value: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，此处的 inline 会使下列函数实际上直接内联到调用处</span></span><br><span class="line"><span class="comment">// 以确保 logging 仅在原始调用位置被调用</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">LogCompositions</span><span class="params">(tag: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">        <span class="keyword">val</span> ref = remember &#123; Ref(<span class="number">0</span>) &#125;</span><br><span class="line">        SideEffect &#123; ref.value++ &#125;</span><br><span class="line">        Log.d(tag, <span class="string">&quot;Compositions: <span class="variable">$msg</span> <span class="subst">$&#123;ref.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyComponent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> counter <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    LogCompositions(TAG, <span class="string">&quot;MyComposable function&quot;</span>)</span><br><span class="line"></span><br><span class="line">    CustomText(</span><br><span class="line">        text = <span class="string">&quot;Counter: <span class="variable">$counter</span>&quot;</span>,</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .clickable &#123;</span><br><span class="line">                counter++</span><br><span class="line">            &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    text: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    LogCompositions(TAG, <span class="string">&quot;CustomText function&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Text(</span><br><span class="line">        text = text,</span><br><span class="line">        modifier = modifier.padding(<span class="number">32.</span>dp),</span><br><span class="line">        style = TextStyle(</span><br><span class="line">            fontSize = <span class="number">20.</span>sp,</span><br><span class="line">            textDecoration = TextDecoration.Underline,</span><br><span class="line">            fontFamily = FontFamily.Monospace</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行此示例时，我们注意到每次计数器的值更改时，两者都会重组。<code>MyComponent``CustomText</code></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://www.jetpackcompose.app/articles/donut-hole-skipping/donut-hole-skipping-example-1.gif" alt="示例：打印日志语句"></p><h1 id="在运行时对重组可视化"><a href="#在运行时对重组可视化" class="headerlink" title="在运行时对重组可视化"></a>在运行时对重组可视化</h1><p>Google Play 团队是Google首批利用 Jetpack Compose 的内部团队之一。他们与 Compose 团队密切合作，甚至<a href="https://android-developers.googleblog.com/2022/03/play-time-with-jetpack-compose.html">编写了一份case study</a>，描述了他们迁移到 Compose 的经验。该帖子的宝藏之一是他们开发的可视化重组<code>Modifier</code>。您可以<a href="https://github.com/android/snippets/blob/master/compose/recomposehighlighter/src/main/java/com/example/android/compose/recomposehighlighter/RecomposeHighlighter.kt">在此处</a>找到修饰符的代码。为了方便，我在下面添加了该代码段；但不要夸我啊，它是由Google Play团队开发的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Copyright 2022 Google Inc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file</span></span><br><span class="line"><span class="comment"> * except in compliance with the License. You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software distributed under the</span></span><br><span class="line"><span class="comment"> * License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment"> * KIND, either express or implied. See the License for the specific language governing</span></span><br><span class="line"><span class="comment"> * permissions and limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.android.compose.recomposehighlighter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.LaunchedEffect</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Stable</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.mutableStateOf</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.remember</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.composed</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.draw.drawWithCache</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.geometry.Offset</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.geometry.Size</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.graphics.Color</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.graphics.SolidColor</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.graphics.drawscope.Fill</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.graphics.drawscope.Stroke</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.graphics.lerp</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.platform.debugInspectorInfo</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.dp</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.util.lerp</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.delay</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A [Modifier] that draws a border around elements that are recomposing. The border increases in</span></span><br><span class="line"><span class="comment"> * size and interpolates from red to green as more recompositions occur before a timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">recomposeHighlighter</span><span class="params">()</span></span>: Modifier = <span class="keyword">this</span>.then(recomposeModifier)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a single instance + @Stable to ensure that recompositions can enable skipping optimizations</span></span><br><span class="line"><span class="comment">// Modifier.composed will still remember unique data per call site.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> recomposeModifier =</span><br><span class="line">    Modifier.composed(inspectorInfo = debugInspectorInfo &#123; name = <span class="string">&quot;recomposeHighlighter&quot;</span> &#125;) &#123;</span><br><span class="line">        <span class="comment">// The total number of compositions that have occurred. We&#x27;re not using a State&lt;&gt; here be</span></span><br><span class="line">        <span class="comment">// able to read/write the value without invalidating (which would cause infinite</span></span><br><span class="line">        <span class="comment">// recomposition).</span></span><br><span class="line">        <span class="keyword">val</span> totalCompositions = remember &#123; arrayOf(<span class="number">0L</span>) &#125;</span><br><span class="line">        totalCompositions[<span class="number">0</span>]++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The value of totalCompositions at the last timeout.</span></span><br><span class="line">        <span class="keyword">val</span> totalCompositionsAtLastTimeout = remember &#123; mutableStateOf(<span class="number">0L</span>) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the timeout, and reset everytime there&#x27;s a recomposition. (Using totalCompositions</span></span><br><span class="line">        <span class="comment">// as the key is really just to cause the timer to restart every composition).</span></span><br><span class="line">        LaunchedEffect(totalCompositions[<span class="number">0</span>]) &#123;</span><br><span class="line">            delay(<span class="number">3000</span>)</span><br><span class="line">            totalCompositionsAtLastTimeout.value = totalCompositions[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Modifier.drawWithCache &#123;</span><br><span class="line">            onDrawWithContent &#123;</span><br><span class="line">                <span class="comment">// Draw actual content.</span></span><br><span class="line">                drawContent()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Below is to draw the highlight, if necessary. A lot of the logic is copied from</span></span><br><span class="line">                <span class="comment">// Modifier.border</span></span><br><span class="line">                <span class="keyword">val</span> numCompositionsSinceTimeout =</span><br><span class="line">                    totalCompositions[<span class="number">0</span>] - totalCompositionsAtLastTimeout.value</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> hasValidBorderParams = size.minDimension &gt; <span class="number">0f</span></span><br><span class="line">                <span class="keyword">if</span> (!hasValidBorderParams || numCompositionsSinceTimeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@onDrawWithContent</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> (color, strokeWidthPx) =</span><br><span class="line">                    <span class="keyword">when</span> (numCompositionsSinceTimeout) &#123;</span><br><span class="line">                        <span class="comment">// We need at least one composition to draw, so draw the smallest border</span></span><br><span class="line">                        <span class="comment">// color in blue.</span></span><br><span class="line">                        <span class="number">1L</span> -&gt; Color.Blue to <span class="number">1f</span></span><br><span class="line">                        <span class="comment">// 2 compositions is _probably_ okay.</span></span><br><span class="line">                        <span class="number">2L</span> -&gt; Color.Green to <span class="number">2.</span>dp.toPx()</span><br><span class="line">                        <span class="comment">// 3 or more compositions before timeout may indicate an issue. lerp the</span></span><br><span class="line">                        <span class="comment">// color from yellow to red, and continually increase the border size.</span></span><br><span class="line">                        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                            lerp(</span><br><span class="line">                                Color.Yellow.copy(alpha = <span class="number">0.8f</span>),</span><br><span class="line">                                Color.Red.copy(alpha = <span class="number">0.5f</span>),</span><br><span class="line">                                min(<span class="number">1f</span>, (numCompositionsSinceTimeout - <span class="number">1</span>).toFloat() / <span class="number">100f</span>)</span><br><span class="line">                            ) to numCompositionsSinceTimeout.toInt().dp.toPx()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> halfStroke = strokeWidthPx / <span class="number">2</span></span><br><span class="line">                <span class="keyword">val</span> topLeft = Offset(halfStroke, halfStroke)</span><br><span class="line">                <span class="keyword">val</span> borderSize = Size(size.width - strokeWidthPx, size.height - strokeWidthPx)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> fillArea = (strokeWidthPx * <span class="number">2</span>) &gt; size.minDimension</span><br><span class="line">                <span class="keyword">val</span> rectTopLeft = <span class="keyword">if</span> (fillArea) Offset.Zero <span class="keyword">else</span> topLeft</span><br><span class="line">                <span class="keyword">val</span> size = <span class="keyword">if</span> (fillArea) size <span class="keyword">else</span> borderSize</span><br><span class="line">                <span class="keyword">val</span> style = <span class="keyword">if</span> (fillArea) Fill <span class="keyword">else</span> Stroke(strokeWidthPx)</span><br><span class="line"></span><br><span class="line">                drawRect(</span><br><span class="line">                    brush = SolidColor(color),</span><br><span class="line">                    topLeft = rectTopLeft,</span><br><span class="line">                    size = size,</span><br><span class="line">                    style = style</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用此修饰符实际上是直白明了 —— 只需将 <code>recomposeHighlighter</code> 修饰符加到要跟踪其重组的可组合项的修饰符链上即可。修饰符在其附加到的可组合体周围绘制一个框，并使用颜色和边框宽度来表示可组合中发生的重组量。</p><table><thead><tr><th>边框颜色</th><th>重组次数</th></tr></thead><tbody><tr><td>蓝</td><td>1</td></tr><tr><td>绿</td><td>2</td></tr><tr><td>黄色到红色</td><td>3+</td></tr></tbody></table><p>让我们来看看它在实际使用时的样子。我们的示例有一个简单的可组合函数，该函数具有一个按钮，该按钮在单击计数器时递增计数器。我们在两个地方使用<code>recomposeHighlighter</code> 修饰符 -——<code>MyButtonComponent</code>本身和``MyTextComponent`，它是按钮的内容。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyButtomComponent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier.recomposeHighlighter()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> counter <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    OutlinedButton(</span><br><span class="line">        onClick = &#123; counter++ &#125;,</span><br><span class="line">        modifier = modifier,</span><br><span class="line">    ) &#123;</span><br><span class="line">        MyTextComponent(</span><br><span class="line">            text = <span class="string">&quot;Counter: <span class="variable">$counter</span>&quot;</span>,</span><br><span class="line">            modifier = Modifier.clickable &#123;</span><br><span class="line">                counter++</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyTextComponent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    text: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = text,</span><br><span class="line">        modifier = modifier</span><br><span class="line">            .padding(<span class="number">32.</span>dp)</span><br><span class="line">            .recomposeHighlighter(),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行此示例时，我们注意到按钮和按钮内的文本最初都有一个蓝色的边界框。这很合理，因为这是第一次重组，它对应于我们使用<code>recomposeHighlighter()</code>修饰符的两个地方。当我们单击按钮时，我们注意到边界框仅围绕按钮内的文本，而不是按钮本身。这是因为 Compose 在重组方面很聪明，它不需要重组整个按钮 —— 只需重组计数器值更改时依赖的那个 Composable 即可。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://www.jetpackcompose.app/articles/debug-recomposition/recompose-highlighter-demo.gif" alt="img"></p><p><em><code>recomposeHighlighter</code>实战</em></p><p>使用此修饰符，我们能够可视化可组合函数中如何发生重组。这是一个非常强大的工具，我能想象出基于此拓展的巨大潜力。</p><h1 id="Compose编译器指标"><a href="#Compose编译器指标" class="headerlink" title="Compose编译器指标"></a>Compose编译器指标</h1><p>前两种调试重组的方法非常有用，并且依赖于观察和可视化。但是，如果我们有一些更确凿的证据来证明Compose编译器如何解释我们的代码，那不是相当nice？这些感觉起来就像魔法一样，毕竟我们经常不知道编译器是否按照我们想要的方式在解释。</p><p>事实证明，Compose 编译器确实有一种机制，能给出关于此信息的详细报告。我上个月发现了它，这让我大吃一惊🤯。这还有<a href="https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md">一些文档</a>，我强烈建议大家阅读。</p><p>启用此报告非常简单 ：您只需在启用 Compose 的模块的<code>build.gradle</code>文件中添加这些编译器参数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">compileKotlin &#123;</span><br><span class="line">    <span class="comment">// Compose Compiler Metrics</span></span><br><span class="line">    freeCompilerArgs += listOf(</span><br><span class="line">        <span class="string">&quot;-P&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=&lt;directory&gt;&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compose Compiler Report</span></span><br><span class="line">    freeCompilerArgs += listOf(</span><br><span class="line">        <span class="string">&quot;-P&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=&lt;directory&gt;&quot;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>让我们更深入地了解一下这些指标告诉我们什么。</del>在我写这篇博文的时候，工程师<a href="https://twitter.com/chrisbanes">克里斯·巴恩斯（Chris Banes</a>）发布了<a href="https://chris.banes.dev/composable-metrics/">一篇博客文章</a>，描述了这些编译器指标，他提供的信息与我希望涵盖的信息完全相同。所以我认为丢个链接到该博客文章会更好些，因为他已经写的很好，更详细地解释了它。</p><p>这些指标包括每个类以及已配置模块中的可组合函数的详细信息。它主要关注对重组方式有直接影响的稳定性（译注：Stable相关）。</p><p>我着实很想强调一些在我尝试时让我感到 surprised 的事情，我相信它也会让绝大多数人感到讶异的。</p><p><strong>注意：</strong>我鼓励您至少浏览一下<a href="https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md">此文档</a>，这样本文其余部分才有意义。对那里面已经提到的信息，我不再赘述。</p><h2 id="如果你使用的类所在模块没有启用compose，则Compose-编译器将无法推断其稳定性"><a href="#如果你使用的类所在模块没有启用compose，则Compose-编译器将无法推断其稳定性" class="headerlink" title="如果你使用的类所在模块没有启用compose，则Compose 编译器将无法推断其稳定性"></a>如果你使用的类所在模块没有启用compose，则Compose 编译器将无法推断其稳定性</h2><p>让我们看一个示例，以了解这意味着什么，以及 Compose 编译器报告如何帮助我发现这种细微差别 -</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleMetadata</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">val</span> url: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们有一个名为<code>ArticleMetadata</code> 的简单数据类。由于它的所有属性都是原始值，因此 Compose 编译器将能够非常轻松地推断其稳定性。值得指出的是，此类是在<strong>未启用 Compose</strong>的模块中定义的。</p><p>由于这是一个简单的数据类，因此我们直接在可组合函数中用它。此函数定义在启用了 Jetpack Compose <strong>的其他模块中</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ArticleCard</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    articleMetadata: <span class="type">ArticleMetadata</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123; .. &#125;</span><br></pre></td></tr></table></figure><p>当我们运行 Compose Compiler Metrics 时，以下是我们在 Compose 插件生成的其中一个文件 （<code>composables.txt</code>） 中找到的内容 -</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restartable <span class="function"><span class="keyword">fun</span> <span class="title">ArticleCard</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  unstable articleMetadata: <span class="type">ArticleMetadata</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">stable</span> <span class="type">modifier</span>: <span class="type">Modifier</span>? = <span class="meta">@static</span> Companion</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>我们看到可组合函数<code>ArticleCard</code>是可重新启动的，但不是可跳过的。这意味着Compose 编译器将无法执行智能优化，例如在参数未更改时跳过此函数的执行。有时这是出于实际选择，但在这种情况下，如果参数没有更改，我们肯定希望跳过此函数的执行。 🤔</p><p>我们看到此行为的原因是，我们使用的是未启用 compose 的模块中的类。这阻止了 Compose 编译器智能地推断稳定性，因此它将此参数视为<code>unstable</code> ，这会影响了此可组合的重组方式。</p><p>有两种方法可以解决此问题：</p><ol><li>向数据类所在的模块添加 compose 支持</li><li>在启用 Compose 的模块中转换为其他类（例如 UI Model 类），并使可组合函数将其作为参数。</li></ol><h2 id="List-参数无法被推断为-Stable，即使它的元素都是原始值"><a href="#List-参数无法被推断为-Stable，即使它的元素都是原始值" class="headerlink" title="List 参数无法被推断为 Stable，即使它的元素都是原始值"></a>List 参数无法被推断为 Stable，即使它的元素都是原始值</h2><p>让我们看一下另一个可组合函数，我们想要分析其指标</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TagsCard</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    tagList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>当我们运行 Compose Compiler Metrics 时，我们看到的是 -</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restartable <span class="function"><span class="keyword">fun</span> <span class="title">TagsCard</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  unstable tagList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">stable</span> <span class="type">modifier</span>: <span class="type">Modifier</span>? = <span class="meta">@static</span> Companion</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>Uh oh！ <code>TagsCard</code>具有与上一个示例相同的问题 —— 此函数可重新启动但不可跳过😭 。这是因为参数<code>tagList</code>不是 Stable 的—— 即使它是原始值类型（<code>String</code>）的 List，Compose 编译器也不会将 List 推断为稳定类型。这可能是因为 List 是一个接口，其实现可以是可变的，也可以是不可变的。</p><p>解决此问题的一种方法是使用包装类并适当地对其进行注解，以使 Compose 编译器明确了解其稳定性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">TagMetadata</span></span>(</span><br><span class="line">    <span class="keyword">val</span> tagList: List&lt;String&gt;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TagsCard</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    tagMetadata: <span class="type">TagMetadata</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>当我们再次运行 Compose Compiler Metrics 时，我们看到编译器能够正确推断出此函数的稳定性🎉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restartable skippable <span class="function"><span class="keyword">fun</span> <span class="title">TagsCard</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  stable tagMetadata: <span class="type">TagMetadata</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">stable</span> <span class="type">modifier</span>: <span class="type">Modifier</span>? = <span class="meta">@static</span> Companion</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>由于这类用例相当常见，所以我很喜欢 Chris Banes 在<a href="https://chris.banes.dev/composable-metrics/">博客文章</a>中提出的可重用的包装类片段。（就是我贴的这段）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>正如您从本文中看到的，有好几种方法可以在 Jetpack Compose 中调试重组。您可能希望3种机制都来点，来在代码库中调试 Composable 函数。尤其是因为对大多数团队，这种构建Android应用程序的新方法还是刚刚发车的阶段。我着实很希望在 Android Studio 本身中对调试 Composable 提供一流的支持，但在那之前，您也有一些选择😉，我鼓励大家使用我在本文中展示的其中一些选项 - 我相信您会像我一样找到一些惊喜。</p><p>我希望我今天能够教你一些新的东西。还有更多文章正在筹备中，我很高兴与你们分享。如果您感兴趣，并想尽早访问它们，可以考虑注册下面的链接。下次见喽！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是 Compose 相关的偏进阶文章，给出了一些可用于 Compose 调试的方法，并阐释了一些性能优化方面的小细节。&lt;/p&gt;
&lt;p&gt;本文译自 &lt;a href=&quot;https://www.jetpackcompose.app/articles/how-can-I-debu</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 自定义布局+物理引擎 = ？</title>
    <link href="https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-physics-layout/"/>
    <id>https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-physics-layout/</id>
    <published>2022-06-23T05:35:21.000Z</published>
    <updated>2022-06-23T05:38:43.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>废话不说，先上图！</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2694fea1b14df7b49b4b789b7b7a2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="PhysicsLayout演示_"></p><p>所对应代码大致为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> physicsConfig = PhysicsConfig()</span><br><span class="line"></span><br><span class="line">PhysicsLayout(modifier = modifier, physicsLayoutState = physicsLayoutState, boundSize = boundSize.toFloat()) &#123;</span><br><span class="line">    RandomColorBox(modifier = Modifier</span><br><span class="line">        .size(<span class="number">40.</span>dp)</span><br><span class="line">        .physics(physicsConfig, initialX = <span class="number">300f</span>, initialY = <span class="number">500f</span>))</span><br><span class="line">    <span class="comment">// This one has a circle shape</span></span><br><span class="line">    <span class="comment">// so you need to modify it with not only a `clip()` Modifier to make it &quot;looks like&quot; a circle</span></span><br><span class="line">    <span class="comment">// but also a `physics(physicsConfig.copy(shape = PhysicsShape.CIRCLE)` Modifier to create a circle Body</span></span><br><span class="line">    RandomColorBox(modifier = Modifier</span><br><span class="line">        .clip(CircleShape)</span><br><span class="line">        .size(<span class="number">50.</span>dp)</span><br><span class="line">        .physics(physicsConfig.copy(shape = PhysicsShape.CIRCLE), <span class="number">300f</span>, <span class="number">1000f</span>))</span><br><span class="line">    RandomColorBox(modifier = Modifier</span><br><span class="line">        .size(<span class="number">60.</span>dp)</span><br><span class="line">        .physics(physicsConfig))</span><br><span class="line">    <span class="keyword">var</span> checked <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Checkbox(...)</span><br><span class="line">    Card(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这之中的<code>PhysicsLayout</code>就是我实现的<code>物理布局</code>了</p><p>如需体验上图的其他功能，可以到Github仓库下载<a href="https://github.com/FunnySaltyFish/JetpackComposePhysicsLayout/blob/master/demo.apk">demo</a>；完整源亦可见仓库</p><h3 id="这是怎么实现的？"><a href="#这是怎么实现的？" class="headerlink" title="这是怎么实现的？"></a>这是怎么实现的？</h3><p>正如标题所言，这是一个自定义布局。关于这方面，我已经写了<strong>5篇文章</strong>详细描述了，感兴趣的同学可以点击我的头像查看。本文所用到的无非就是那里的知识加上<code>JBox2d</code>而已，看完之后你也写的出来</p><h4 id="JBox2d"><a href="#JBox2d" class="headerlink" title="JBox2d"></a>JBox2d</h4><blockquote><p>JBox2D是开源的2D物理引擎，能够根据开发人员设定的参数，如重力、密度、摩擦系数和弹性系数等，自动进行2D刚体物理运动的模拟。</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>本布局参考自<a href="https://github.com/Jawnnypoo/PhysicsLayout">Jawnnypoo/PhysicsLayout: Android layout that simulates physics using JBox2D (github.com)</a>，其中部分代码也来自于那里，在此表示诚挚的感谢！( 不过我进行了大量的修改，以使原先用于 <code>View</code>的代码被用于<code>Compose</code>）</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>首先，我们先来想一个事情：现在每个物体其实都有自己的<strong>位置、大小、形状</strong>这些参数，那么<strong>父布局怎么获得这些值</strong>呢？如果你读过我的<a href="https://juejin.cn/post/7073307559792214024">深入Jetpack Compose——布局原理与自定义布局（四）ParentData</a>，估计可以想到：这是利用<code>ParentData</code>传递的。所以咱们先写个自定义的<code>ParentData</code>吧</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhysicsParentData</span></span>(</span><br><span class="line">    <span class="keyword">var</span> physicsConfig: PhysicsConfig = PhysicsConfig(),</span><br><span class="line">    <span class="keyword">var</span> initialX: <span class="built_in">Float</span> = <span class="number">0f</span>,</span><br><span class="line">    <span class="keyword">var</span> initialY: <span class="built_in">Float</span> = <span class="number">0f</span>,</span><br><span class="line">    <span class="keyword">var</span> width: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">var</span> height: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>PhysicsConfig</code>代表基本的物理配置，我们先不细究，其余的就是<strong>初位置和宽高了</strong>。</p><p>有了<code>ParentData</code>，那是不是也得有对应的修饰符和作用域啊，所以咱们写一写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PhysicsLayoutScope</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">physics</span><span class="params">(physicsConfig: <span class="type">PhysicsConfig</span>, initialX : <span class="type">Float</span> = <span class="number">0</span>f, initialY : <span class="type">Float</span> = <span class="number">0</span>f)</span></span> : Modifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> PhysicsLayoutScopeInstance : PhysicsLayoutScope &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">physics</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        physicsConfig: <span class="type">PhysicsConfig</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        initialX: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        initialY: <span class="type">Float</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Modifier = <span class="keyword">this</span>.then(PhysicsParentData(physicsConfig, initialX, initialY))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码都很简单，属于是自定义<code>Modifier</code>的基本操作了，如果你看不懂可以先了解了解再来</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>现在<code>Modifier</code>的定义差不多了，接下来就是使用了。其实总结下来就是这个过程</p><ol><li><p>初始化各个物体和世界</p></li><li><p>用代码不断模拟一下各个物体的运动过程</p></li><li><p>在Layout过程中获取位置并正确摆放出来</p></li></ol><p>咱们分别来看<em>（下面的内容只是我的思路，有些地方可能不太优雅，如果您有更好的想法欢迎指出！）</em></p><p>整体来说，应该有一些代码专门负责物理模拟的过程，这一部分在代码中为<code>Physics</code>类，它负责进行具体的<code>物理世界创造</code>、<code>进行物理模拟</code>等过程。此处不赘述。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>考虑到各子微件的具体信息要到<code>Layout</code>才能读取到，所以似乎只能在这里初始化；但是<code>Layout</code>又会反复进行，而初始化应该只进行一次。所以用个变量来控制吧</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initialized <span class="keyword">by</span> remember &#123;</span><br><span class="line">    mutableStateOf(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后第一次<code>Layout</code>时读取各<code>ParentData</code>并存起来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> placeables = measurables.mapIndexed &#123; index,  measurable -&gt;</span><br><span class="line">    <span class="keyword">val</span> physicsParentData = (measurable.parentData <span class="keyword">as</span>? PhysicsParentData) ?: PhysicsParentData()</span><br><span class="line">    <span class="keyword">if</span> (!initialized)&#123;</span><br><span class="line">        parentDataList.add(index, physicsParentData)</span><br><span class="line">    &#125;</span><br><span class="line">    measurable.measure(childConstraints)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开个副作用，在所有<strong>物体信息</strong>初始化好后创建世界并创建<strong>Body</strong>（在<code>JBox2d</code>中代表<code>刚体</code>的类）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化世界</span></span><br><span class="line">LaunchedEffect(initialized)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialized) <span class="keyword">return</span><span class="symbol">@LaunchedEffect</span></span><br><span class="line">    physics.createWorld &#123; body, i -&gt;</span><br><span class="line">        parentDataList[i].body = body</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>createWord</code>方法负责创建<code>Body</code>并在每个<code>Body</code>创建完后回调</p><h5 id="不断模拟"><a href="#不断模拟" class="headerlink" title="不断模拟"></a>不断模拟</h5><p>模拟的工作交给<code>JBox2d</code>，我们要做的就是<code>不断</code>就行。所以<code>while</code>循环吧</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LaunchedEffect(key1 = <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        delay(<span class="number">16</span>)</span><br><span class="line">        physics.step() <span class="comment">// 模拟 16ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读取并正确放置"><a href="#读取并正确放置" class="headerlink" title="读取并正确放置"></a>读取并正确放置</h5><p>这个就很简单了，在<code>Layout</code>方法里<code>layout()</code>中读一下各个<code>Body</code>的位置并<code>place</code>就行</p><p>不过这里注意，因为<code>Body</code>有旋转角度，所以在<code>place</code>的时候需要使用<code>placeWithLayer</code>，该方法签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Placeable.<span class="title">placeWithLayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    position: <span class="type">IntOffset</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    zIndex: <span class="type">Float</span> = <span class="number">0</span>f,</span></span></span><br><span class="line"><span class="params"><span class="function">    layerBlock: <span class="type">GraphicsLayerScope</span>.() -&gt; <span class="type">Unit</span> = DefaultLayerBlock</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>其中第三个参数<code>layerBlock</code>就提供了<code>缩放、选择</code>等方法。具体代码是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">layout(constraints.maxWidth, constraints.maxHeight)&#123;</span><br><span class="line">    placeables.forEachIndexed &#123; i, placeable: Placeable -&gt;</span><br><span class="line">        <span class="keyword">val</span> x = physics.metersToPixels(parentDataList[i].x).toInt() - placeable.width / <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> y = physics.metersToPixels(parentDataList[i].y).toInt() - placeable.height / <span class="number">2</span></span><br><span class="line">          </span><br><span class="line">        placeable.placeWithLayer(IntOffset(x,y), zIndex = <span class="number">0f</span>, layerBlock = &#123;</span><br><span class="line">             rotationZ = parentDataList[i].rotation</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>metersToPixels</code>用于将<strong>物理世界的坐标映射到现实</strong></p><p>完工！</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>其实目前来看，代码里还有些地方感觉不大对劲，比如，为了触发<code>Layout</code>过程，我实际使用了一个并无任何用处的<code>state</code>。因为在我的尝试里，只要<code>layout</code>块里不出现<code>state</code>的变化，它就不会重新触发（这点当然符合Compose的感觉喽）；我想不到什么好点子，只好这么处理了。如果大家有什么好想法，欢迎探讨和PR</p><p>如果你好奇有什么用……额，我也不知道有什么实际用处。我就是觉得很好玩儿，很早之前就想做了，最近下定决心，两天完成，感觉效果还不错。</p><p>如果你对Compose完整项目感兴趣，欢迎看看我的开源项目<a href="https://github.com/FunnySaltyFish/FunnyTranslation">FunnySaltyFish/FunnyTranslation: 基于Jetpack Compose开发的翻译软件，支持多引擎、插件化~</a>    </p><p>本文代码：<a href="https://github.com/FunnySaltyFish/JetpackComposePhysicsLayout">FunnySaltyFish/JetpackComposePhysicsLayout: Jetpack Compose custom layout that simulates physics using JBox2D</a> ，欢迎Star！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;效果&quot;&gt;&lt;a href=&quot;#效果&quot; class=&quot;headerlink&quot; title=&quot;效果&quot;&gt;&lt;/a&gt;效果&lt;/h3&gt;&lt;p&gt;废话不说，先上图！&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R0lGODdhAQABAPAAAMPD</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose LazyGrid全解</title>
    <link href="https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-lazy-grid/"/>
    <id>https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-lazy-grid/</id>
    <published>2022-06-23T05:34:07.000Z</published>
    <updated>2022-06-23T05:34:47.465Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考自谷歌官方视频<a href="https://www.youtube.com/watch?v=1ANt65eoNhQ">Lazy layouts in Compose - YouTube</a>，基于<code>Compose 1.2.0-beta02</code>（截止发文时最新版本）</p><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间Compose发布了<code>1.2.0</code>beta版本，最大的变化之一莫过于<code>LazyLayout</code>去除了实验性标志。所以接下来，咱们不妨一起看看<code>LazyGrid</code>的用法<del>（嗯？这和上一句有关系吗）</del></p><p><code>LazyGrid</code>包含两种微件：<code>LazyVerticalGrid</code>和<code>LazyHorizontalGrid</code>。两者内部均由<code>LazyLayout</code>实现（包括<code>LazyColumn</code>和<code>LazyRow</code>也是由<code>LazyLayout</code>实现的）。不过今天我们不去考虑底层的<code>LazyLayout</code>，单纯着眼于Grid们</p><p>为行文方便，此处仅以<code>LazyVerticalGrid</code>为例。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>最简单的使用如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SimpleLazyGrid</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LazyVerticalGrid(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        <span class="comment">// 固定两列</span></span><br><span class="line">        columns = GridCells.Fixed(<span class="number">2</span>) ,</span><br><span class="line">        content = &#123;</span><br><span class="line">            items(<span class="number">12</span>)&#123;</span><br><span class="line">                RandomColorBox(modifier = Modifier.height(<span class="number">200.</span>dp))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到的<code>RandomColorBox</code>仅仅是Box加上随机颜色的背景，唯一注意的是对于LazyLayout，因为涉及到重组过程，所以如果需要记住这个Color（重组时颜色不变），则需要使用<code>rememberSaveable</code>，其余不再赘述</p><p>上面的效果如下</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/62885f44ef1d5.png" alt="image-20220521114045882" style="zoom:33%;" /><p>简单的网格布局就实现了</p><h3 id="添加间隙"><a href="#添加间隙" class="headerlink" title="添加间隙"></a>添加间隙</h3><p>要为子元素之间添加空隙也很简单，指定一下<code>arrangemnt</code>为<code>spacedBy</code>即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">horizontalArrangement = Arrangement.spacedBy(<span class="number">12.</span>dp),</span><br><span class="line">   verticalArrangement = Arrangement.spacedBy(<span class="number">8.</span>dp)</span><br></pre></td></tr></table></figure><p>效果如下</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/6288635e4aa70.png" alt="image-20220521115822198" style="zoom:33%;" /><p>当然也可以添加整体的外边距，设置<code>contentPadding = PaddingValues()</code>即可，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contentPadding = PaddingValues(<span class="number">12.</span>dp)</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/628863a93e591.png" alt="image-20220521115937301" style="zoom:33%;" /><h3 id="适应大小"><a href="#适应大小" class="headerlink" title="适应大小"></a>适应大小</h3><p>上述情况实际上会根据最大宽度来调整，在横屏状态下就可能会惨不忍睹（比如你加载有图片的情况）</p><p>所以除了固定列数外，还可以固定宽度，由Compose自动确定要放几列。这个也很简单，就是设置<code>columns</code>参数为<code>Adaptive</code>即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定宽度，自适应列数</span></span><br><span class="line">columns = GridCells.Adaptive(<span class="number">200.</span>dp) ,</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>横屏</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/628864cc103b5.png" alt="image-20220521120428237" style="zoom:33%;" /><p>竖屏</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/6288650f1b531.png" alt="image-20220521120535282" style="zoom:33%;" /><p>可以看到，我们指定的<code>200.dp</code>是最小值，由于能够容纳一个又无法容纳两个，Compose为我们自动调整为了只放一个，占满全部剩余宽度。</p><h3 id="异形与自定义"><a href="#异形与自定义" class="headerlink" title="异形与自定义"></a>异形与自定义</h3><h4 id="某些元素占满全部宽度"><a href="#某些元素占满全部宽度" class="headerlink" title="某些元素占满全部宽度"></a>某些元素占满全部宽度</h4><p><code>item</code>和<code>items</code>均有<code>span</code>参数，设置此参数即可设定当前元素会占据几格</p><p>对于下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定列数</span></span><br><span class="line">columns = GridCells.Fixed(<span class="number">3</span>) ,</span><br><span class="line">content = &#123;</span><br><span class="line">    item(span = &#123;</span><br><span class="line">        <span class="comment">// 占据最大宽度</span></span><br><span class="line">        GridItemSpan(maxLineSpan)</span><br><span class="line">    &#125;)&#123;</span><br><span class="line">        RandomColorBox(modifier = Modifier.height(<span class="number">50.</span>dp))</span><br><span class="line">    &#125;</span><br><span class="line">    items(<span class="number">12</span>)&#123;</span><br><span class="line">        RandomColorBox(modifier = Modifier.height(<span class="number">200.</span>dp))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>最上面那个元素就会占据一行，如下：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/628868661e391.png" alt="image-20220521121950200" style="zoom:33%;" /><p>上面用到的<code>maxLineSpan</code>即为当前行的最大Span，除此之外，还有另一个值<code>maxCurrentLineSpan</code>，二者之间关系如下</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/62886ef54dec5.png" alt="image-20220521124749563"></p><h4 id="更复杂的自定义"><a href="#更复杂的自定义" class="headerlink" title="更复杂的自定义"></a>更复杂的自定义</h4><p><code>columns</code>其实可以自定义，比方说，我们需要让一行中三个元素，宽度分别为<strong>1:2:1</strong>，那其实可以这样写。具体细节请参考下面的源码，返回的值即为各元素的宽度组成的<code>List</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义实现1:2:1</span></span><br><span class="line">columns = <span class="keyword">object</span>  : GridCells &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">calculateCrossAxisCellSizes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        availableSize: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        spacing: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: List&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 总共三个元素，所以其实两个间隔</span></span><br><span class="line">        <span class="comment">// |元素|间隔|元素|间隔|元素|</span></span><br><span class="line">        <span class="comment">// 计算一下所有元素占据的空间</span></span><br><span class="line">        <span class="keyword">val</span> availableSizeWithoutSpacing = availableSize - <span class="number">2</span> * spacing</span><br><span class="line">        <span class="comment">// 小的两个大小即为剩余空间（总空间-间隔）/4</span></span><br><span class="line">        <span class="keyword">val</span> smallSize = availableSizeWithoutSpacing / <span class="number">4</span></span><br><span class="line">        <span class="comment">// 大的那个就是除以2呗</span></span><br><span class="line">        <span class="keyword">val</span> largeSize = availableSizeWithoutSpacing / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> listOf(smallSize, largeSize, smallSize)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/62886c7ee0b67.png" alt="image-20220521123719082" style="zoom:33%;" /><p>其余的效果大家就发挥想象啦</p><p>如果你想对排列方式也自定义，可以自己实现<code>Arrangement.Vertical</code>，视频中有给出例子(18:51左右)。这里感觉用处不大，不赘述了</p><h3 id="一些提示-For-LazyLayout"><a href="#一些提示-For-LazyLayout" class="headerlink" title="一些提示 For LazyLayout"></a>一些提示 For LazyLayout</h3><ol><li><p>不要设置大小为0的控件</p><p>这类问题主要在异步加载的场景中，可能加载之前你会将原本的大小设置为0（就是什么也没有）。在这种情况下，Compose在初始时将测量所有内容（因为他们高度为0，所以都在屏幕内），之后当数据加载完后，Compose又会重新重组。</p><p>相反，你应当<strong>尽量保证数据加载前后item整体大小不变</strong>（如手动设置高度、使用placeholder等），以帮助LazyLayout正确计算哪些会被显示在屏幕上</p></li><li><p>避免嵌套同方向的可滚动微件</p><p>避免使用如下代码（其实你这么用会直接报错）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Column(modifier = Modifier.verticalScroll()) &#123;</span><br><span class="line">    LazyColumn(<span class="comment">/*这里不设置高度*/</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而应当改为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LazyColumn &#123;</span><br><span class="line">    item &#123; Header() &#125;</span><br><span class="line">    items()&#123; &#125;</span><br><span class="line">    item&#123; Footer() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>谨慎将多个子微件放到同一<code>item</code>中</p><p>即谨慎写出类似下面的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LazyColumn &#123;</span><br><span class="line">    item &#123;</span><br><span class="line">        <span class="comment">// 两个微件放在同一item里</span></span><br><span class="line">        RandomColorBox(modifier = Modifier.size(<span class="number">40.</span>dp))</span><br><span class="line">        RandomColorBox(modifier = Modifier.size(<span class="number">40.</span>dp))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，Compose尽管可以按顺序渲染出这些子微件，但同一个<code>item</code>下的微件<strong>会被当作一个整体。如果某一部分可见，则其与部分也会被一起重组和绘制</strong>，可能会影响性能。在最严重情况下，整个<code>LazyColumn</code>仅包含一个<code>item</code>，那就完全失去了<code>Lazy</code>的特性。另一个问题是对于<code>scrollToItem()</code>这类方法，它们的index在计算时是按<code>item</code>而不是所有内部子元素排列的，也就是说，对于下面的例子，尽管总共有4个微件，但算index的时候只有0/1/2三个而已。</p></li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/21/6288a3811fe95.png" alt="image-20220521163154088"></p><p>​    不过也有些情况倒是推荐这么用，比如在<code>item</code>中包含微件本身和<code>Divider</code>。一是二者本身语义上就相关联，Divider也不该影响index；二是Divider较小，不影响性能</p><ol start="4"><li>使用Type</li></ol><p>如果你的列表项有多种不同的类型，可以在<code>item</code>或<code>items</code>方法中指定<code>contentType</code>，这有助于Compose在重组时选择相同Type的微件进行复用，可以提高性能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contentType = &#123; <span class="keyword">data</span>.type &#125;</span><br></pre></td></tr></table></figure><h3 id="Google画的饼"><a href="#Google画的饼" class="headerlink" title="Google画的饼"></a>Google画的饼</h3><p>参考的视频中Google其实画了些饼</p><ol><li>瀑布流布局正在开发中</li><li>item添加和删除的动画也正在开发中</li></ol><p>目前<code>RecyclerView</code>对应的瀑布流布局<code>Compose</code>中还没有对应实现，我试图用<code>VerticalLazyGrid</code>实现然并不行，它摆放的时候会确保每行高度一样……目前的开源库都是多个<code>LazyColumn</code>并排实现的伪效果。所以还是等吧</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本文所有代码见：<a href="https://github.com/FunnySaltyFish/JetpackComposeStudy">FunnySaltyFish/JetpackComposeStudy: Jetpack Compose学习分享 (github.com)</a></p><p>受限于本人水平，如有错误，敬请指正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文参考自谷歌官方视频&lt;a href=&quot;https://www.youtube.com/watch?v=1ANt65eoNhQ&quot;&gt;Lazy layouts in Compose - YouTube&lt;/a&gt;，基于&lt;code&gt;Compose 1.2.0-beta02&lt;/code</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 自定义绘制——高仿Keep周运动数据页面</title>
    <link href="https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-fake-keep/"/>
    <id>https://blog.funnysaltyfish.fun/2022/06/23/jetpack-compose-fake-keep/</id>
    <published>2022-06-23T05:33:11.000Z</published>
    <updated>2022-06-23T05:35:06.620Z</updated>
    
    <content type="html"><![CDATA[<p>废话之前先上图吧，如果不是有人告诉，你可以一眼看出哪个是真哪个是假吗？</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/30/629440b27e66d.png" alt="Snipaste_2022-05-29_23-50-49"></p><p>仿制整个页面（仅仅页面）大概花了我两个小时，不过仅仅是静态的、不可点击的。图有形似而无功能。</p><h3 id="自定义绘制"><a href="#自定义绘制" class="headerlink" title="自定义绘制"></a>自定义绘制</h3><p>Jetpack Compose 自定义绘制的文章其实并不少了，基本代码上和<code>View</code>体系基本类似，就是方法上有所差异</p><p>详细的内容可以见其他作者的文章，如</p><ul><li><code>路很长OoO</code>的<a href="https://juejin.cn/post/6937700592340959269">JetPack-Compose - 自定义绘制 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/user/1714893871911502">RugerMc</a>的<a href="https://juejin.cn/post/6999889489166336007">使用 Jetpack Compose 完成自定义绘制 - 掘金 (juejin.cn)</a></li><li>……</li></ul><p>我就不赘述</p><p>上述代码中，中间那块数据图就是自己画的（Keep 用的是 <code>RecyclerView</code>）。大致上，包括这几个部分</p><ol><li>四个浅色矩形和底部文字</li><li>三条浅色横线和一条深色横线</li><li>中间的深色矩形和底部文字</li><li>中间竖线、矩形和底部的小线段</li></ol><p>其中1-&gt;3的顺序不能更改，因为三条浅色横线在浅色矩形之上，但是在深色矩形之下</p><h4 id="浅色矩形"><a href="#浅色矩形" class="headerlink" title="浅色矩形"></a>浅色矩形</h4><p>页面上一共4个浅色矩形，观察Keep可知，它们的高度与 <strong>对应数据和运动记录中最长时间之比</strong> 成正比</p><p>所以先计算一下最大的数字，找一些变量存储宽高：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画布的宽高</span></span><br><span class="line"><span class="keyword">val</span> w = size.width</span><br><span class="line"><span class="keyword">val</span> h = size.height</span><br><span class="line"><span class="comment">// 最高的矩形占的高度（3/6)</span></span><br><span class="line"><span class="keyword">val</span> maxH = h / <span class="number">2</span></span><br><span class="line"><span class="comment">// 最大的数字，所有矩形以这个为基准计算高度</span></span><br><span class="line"><span class="keyword">val</span> maxNum = listData.maxOf &#123; it.num &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以及一个参数</span></span><br><span class="line">startIndex: <span class="built_in">Int</span> <span class="comment">//最左侧的矩阵对应的index</span></span><br></pre></td></tr></table></figure><p>其中列表Bean<code>ItemData</code>定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemData</span></span>(<span class="keyword">val</span> content :String, <span class="keyword">val</span> num : <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>然后计算对应位置（左上角）和大小（宽高）即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until min(<span class="number">5</span>, listData.size - startIndex))&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = listData[startIndex + i]</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 画四个浅色矩形</span></span><br><span class="line">        <span class="keyword">val</span> blockH = <span class="keyword">data</span>.num.toFloat() / maxNum * maxH</span><br><span class="line">        drawRect(lightColor, Offset(w / <span class="number">4f</span> * i - blockW / <span class="number">2</span>, <span class="number">0.833f</span> * h - blockH), Size(blockW, blockH))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浅色矩形对应的文字也是类似，不过由于Canvas并不能直接画文字，所以要先获取到<code>canvas.nativeCanvas</code>再在它上面<code>drawText</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    <span class="comment">// 浅色矩形下方的文字</span></span><br><span class="line">    paint.color = Color.Gray.toArgb()</span><br><span class="line">    drawIntoCanvas &#123;</span><br><span class="line">        FunnyCanvasUtils.drawCenterText(it.nativeCanvas, <span class="keyword">data</span>.content, w / <span class="number">4f</span> * i , h * <span class="number">7</span> / <span class="number">8</span> + <span class="number">2f</span>,  rect, paint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>这里用到了一个方法<code>drawCenterText</code>就是让文字以给定的<code>x,y</code>为<code>横向中心点，纵向baseline</code>为基准进行绘制，感兴趣的可以看源码（见文末），此处不在赘述</p><h3 id="画横线"><a href="#画横线" class="headerlink" title="画横线"></a>画横线</h3><p>画线的方法就是<code>drawLine</code>，给出两个<code>Offset</code>分别表示起点和终点即可。唯一注意的是，由于要画虚线，所以要设置<code>pathEffect = PathEffect.dashPathEffect</code>并给出一个二元数组（表示线长、间隔）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三条浅色横线</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until <span class="number">5</span>)&#123;</span><br><span class="line">    drawLine(Color.Black.copy(alpha = <span class="number">0.5f</span>), Offset(<span class="number">0f</span>, h * i / <span class="number">6</span>), Offset(w, h * i / <span class="number">6</span>), pathEffect = PathEffect.dashPathEffect(</span><br><span class="line">        floatArrayOf(<span class="number">10f</span>,<span class="number">10f</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的就不赘述了，本质上就是计算着不同位置，画不同的东西而已。可以自行见源码</p><h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><p>至于图片上的其他部分，则是这样组成的：</p><p>最上面一部分直接就是图片（哈哈）</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/30/629448b4976f0.png" alt="image-20220530123148596" style="zoom: 50%;" /><p>这一行是一个<code>Row</code>，两端对齐</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/30/629448d93b8bd.png" alt="image-20220530123225279" style="zoom:50%;" /><p>这一行也是一个<code>Row</code>，以文本<code>baseline</code>对齐</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/30/629449036ed36.png" alt="image-20220530123307519" style="zoom:50%;" /><p>下面是<code>Row</code>套三个<code>Column</code></p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://img.funnysaltyfish.fun/i/2022/05/30/6294492d1dae3.png" alt="image-20220530123349099" style="zoom:50%;" /><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>暂时就是这样，Jetpack Compose 的 布局和绘制到此5篇（前几篇见我的文章），下一篇我会发个很好玩儿的内容，是Layout的蜜汁用法，敬请期待。</p><p>如果你对 Jetpack Compose 开发完整项目有兴趣，鄙人毛遂自荐下自己的开源项目<a href="https://github.com/FunnySaltyFish/FunnyTranslation">FunnySaltyFish/FunnyTranslation: 基于Jetpack Compose开发的翻译软件，支持多引擎、插件化~ </a></p><p>本文所有代码见<a href="https://github.com/FunnySaltyFish/JetpackComposeStudy">此处</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;废话之前先上图吧，如果不是有人告诉，你可以一眼看出哪个是真哪个是假吗？&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=&quot; data-lazy-s</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移完毕</title>
    <link href="https://blog.funnysaltyfish.fun/2022/03/28/migrate-finish/"/>
    <id>https://blog.funnysaltyfish.fun/2022/03/28/migrate-finish/</id>
    <published>2022-03-28T02:40:59.000Z</published>
    <updated>2022-06-23T05:40:14.397Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于 CDN <code>jsdelivr</code> 难以访问，以及 <code>Gitee</code> 于 2022/03/25 突然禁止图床链接，我于 2022/03/26-2022/03/28 进行了博客迁移工作<br>主要内容包括：</p><ul><li>更换 <code>jsdelivr</code> 为 <code>cdn.jsdelivr.net</code></li><li>更换 图片链接 到个人服务器</li><li>基于 Lsky Pro 2.0 搭建新图床，之后的图片将保存于自建图床<br>完毕！</li></ul><p>更新：<br>2022年6月23日，我又将 cdn 迁回 jsdelivr</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;鉴于 CDN &lt;code&gt;jsdelivr&lt;/code&gt; 难以访问，以及 &lt;code&gt;Gitee&lt;/code&gt; 于 2022/03/25 突然禁止图床链接，我于 2022/03/26-2022/03/28 进行了博客迁移工作&lt;br&gt;主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深入Jetpack Compose——布局原理与自定义布局（四）</title>
    <link href="https://blog.funnysaltyfish.fun/2022/03/10/jetpack-compose-layout-4/"/>
    <id>https://blog.funnysaltyfish.fun/2022/03/10/jetpack-compose-layout-4/</id>
    <published>2022-03-10T03:47:16.000Z</published>
    <updated>2022-03-28T02:37:06.940Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://juejin.cn/post/7068164264363556872">文章</a>，我们接触了固有特性测量。这一篇，我们将探索<code>ParentData</code></p><h3 id="ParentData"><a href="#ParentData" class="headerlink" title="ParentData"></a>ParentData</h3><h4 id="曾经的例子"><a href="#曾经的例子" class="headerlink" title="曾经的例子"></a>曾经的例子</h4><p>让我们回忆一下第一篇文章中提到的例子，为了实现如下效果</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202121752667.png" alt="左上角的圆角是屏幕边缘"></p><p>我们当时使用了这样一串修饰符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Box(modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .wrapContentSize(align = Alignment.Center)</span><br><span class="line">            .size(<span class="number">50.</span>dp)</span><br><span class="line">            .background(Color.Blue))</span><br></pre></td></tr></table></figure><p>也就是说，子微件的居中是它自己的<code>wrapContentSize(align = Alignment.Center)</code>调整的结果。那么，如果我们现在知道了子微件（小的蓝色方块）被包裹在另一个方块（Box）里，我们能不能让父布局帮忙确定居中位置呢？</p><p>答案是可以的！<code>Box</code> 在其<code>content</code>作用域中提供了<code>align</code> 方法，这可以让<strong>子微件自行告知父布局：我需要居中</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Box</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// content 提供了 BoxScope</span></span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">BoxScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> measurePolicy = rememberBoxMeasurePolicy(contentAlignment, propagateMinConstraints)</span><br><span class="line">    Layout(</span><br><span class="line">        content = &#123; BoxScopeInstance.content() &#125;,</span><br><span class="line">        measurePolicy = measurePolicy,</span><br><span class="line">        modifier = modifier</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>BoxScope</code>的源码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BoxScope</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">align</span><span class="params">(alignment: <span class="type">Alignment</span>)</span></span>: Modifier</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">matchParentSize</span><span class="params">()</span></span>: Modifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为接口，在此作用域中，子微件就可以调用<code>align</code>告诉父微件自己的align方式了</p><p>所以上面的效果这可以这样实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ModifierSample2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 父元素</span></span><br><span class="line">    Box(modifier = Modifier</span><br><span class="line">        .width(<span class="number">200.</span>dp)</span><br><span class="line">        .height(<span class="number">300.</span>dp)</span><br><span class="line">        .background(Color.Yellow))&#123;</span><br><span class="line">        <span class="comment">// 子元素</span></span><br><span class="line">        Box(modifier = Modifier</span><br><span class="line">            .align(Alignment.Center)</span><br><span class="line">            .size(<span class="number">50.</span>dp)</span><br><span class="line">            .background(Color.Blue))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果是一样的</p><p>不像我们之前看到的<code>布局修饰符</code>，align是<code>父级数据修饰符</code>。本质上，这类由子微件向父布局通信就是由<code>parentData</code>实现的。如上面的<code>align</code>最终会涉及到如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> parentData: Any?</span><br><span class="line">        <span class="keyword">get</span>() = with(modifier) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * ParentData provided through the parentData node will override the data provided</span></span><br><span class="line"><span class="comment">             * through a modifier</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            layoutNode.measureScope.modifyParentData(wrapped.parentData)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p><code>ParentDataModifier</code>源码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个修饰符[Modifier]，为父布局[Layout]提供数据. </span></span><br><span class="line"><span class="comment"> * 可在[Layout]的 measurement 和 positioning 过程中通过 [IntrinsicMeasurable.parentData] 读取到.</span></span><br><span class="line"><span class="comment"> * parent data 通常被用于告诉父布局：子微件应该如何测量和定位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ParentDataModifier</span> : <span class="type">Modifier.Element &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provides a parentData, given the [parentData] already provided through the modifier&#x27;s chain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span>: Any?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尝试用用：咸鱼的“地摊”"><a href="#尝试用用：咸鱼的“地摊”" class="headerlink" title="尝试用用：咸鱼的“地摊”"></a>尝试用用：咸鱼的“地摊”</h4><p>接下来我们尝试用用它。我们来假想这样一个布局：<code>小咸鱼的地摊</code></p><ul><li><p>“地摊”里面有一些微件，它们一个一个纵向排列</p></li><li><p>每个子微件都是“付费”的，比如某一个<code>Box</code>“售价”100，另一个<code>Box</code>“售价”200……以此类推</p></li><li><p>每个子微件会显示自己的价格，而“地摊”会显示总价钱</p></li></ul><p>上述描述换成代码的话就是：每一个子微件通过自定义的<code>Modifier</code>定义自身的价格，并把它传递给父布局，父布局计算所有的价格累积在一起，并显示出来。</p><p>开始写代码吧。我们先定义一个类，继承自<code>ParentDataModifier</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者 FunnySaltyFish (http://funnysaltyfish.fun)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountNumParentData</span></span>(<span class="keyword">var</span> countNum: <span class="built_in">Int</span>) : ParentDataModifier &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span> = <span class="keyword">this</span><span class="symbol">@CountNumParentData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（为了简单起见，我们将<code>modifyParentData</code>这个方法直接返回自身了。在原版<code>Column</code>的实现中，这个方法实际类似这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span> =</span><br><span class="line">    ((parentData <span class="keyword">as</span>? RowColumnParentData) ?: RowColumnParentData()).also &#123;</span><br><span class="line">        it.weight = weight</span><br><span class="line">        it.fill = fill</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>）</p><p>然后我们编写一个简单的<code>Modifier</code>，返回一个实例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">count</span><span class="params">(num: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span>.then(</span><br><span class="line">        <span class="comment">// 这部分是 父级数据修饰符</span></span><br><span class="line">        CountNumParentData(num)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>接下来我们复用一下之前的<code>VerticalLayout</code>，只不过在里面读取一下<code>ParentData</code>而已，部分代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">Layout(</span><br><span class="line">    modifier = modifier,</span><br><span class="line">    content = content</span><br><span class="line">) &#123; measurables: List&lt;Measurable&gt;, constraints: Constraints -&gt;</span><br><span class="line">    <span class="keyword">val</span> placeables = measurables.map &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.parentData <span class="keyword">is</span> CountNumParentData) &#123;</span><br><span class="line">            num += (it.parentData <span class="keyword">as</span> CountNumParentData).countNum</span><br><span class="line">        &#125;</span><br><span class="line">        it.measure(constraints)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略布局的其他代码</span></span><br><span class="line">    Log.d(TAG, <span class="string">&quot;CountChildrenNumber: 总价格是：<span class="variable">$num</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行一下这个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CountNumTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CountChildrenNumber &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123;</span><br><span class="line">            Box(</span><br><span class="line">                modifier = Modifier</span><br><span class="line">                    .size(<span class="number">40.</span>dp)</span><br><span class="line">                    .background(randomColor())</span><br><span class="line">                    .count(Random.nextInt(<span class="number">30</span>, <span class="number">100</span>))</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202203071601534.png" alt="image-20220307160129098"></p><p>对应的总价格输出如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202203071602599.png" alt="image-20220307160211472"></p><p>你可能注意到了，上面的Box里面还用文字指明了自己的“售价”，但调用的代码却没用到<code>Text</code>。这里的文本又是怎么画的呢？</p><p>答案就是刚刚的<code>count</code>Modifier，除了作为<code>父级数据修饰符</code>外，它还发挥了修饰自身的作用。它的代码完整如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">count</span><span class="params">(num: <span class="type">Int</span>)</span></span> = <span class="keyword">this</span>.drawWithContent &#123;</span><br><span class="line">        drawIntoCanvas &#123; canvas -&gt;</span><br><span class="line">            <span class="keyword">val</span> paint = android.graphics</span><br><span class="line">                .Paint()</span><br><span class="line">                .apply &#123;</span><br><span class="line">                    textSize = <span class="number">40F</span></span><br><span class="line">                &#125;</span><br><span class="line">            canvas.nativeCanvas.drawText(num.toString(), <span class="number">0F</span>, <span class="number">40F</span>, paint)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绘制 Box 自身内容</span></span><br><span class="line">        drawContent()</span><br><span class="line">    &#125;</span><br><span class="line">    .then(</span><br><span class="line">        <span class="comment">// 这部分是 父级数据修饰符</span></span><br><span class="line">        CountNumParentData(num)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这里用到了绘制时的部分内容，如果你感兴趣的话，后面我还可能介绍一下自定义绘制。嗯，挖了个坑，之后再填吧~</p><p><code>ParentData</code>的实际场景主要集中在父布局对子微件的特殊位置和大小的控制上，比如<code>Box</code>的<code>align</code>，<code>Column</code>和<code>Row</code>的<code>align</code>、<code>alignBy</code>、<code>weight</code>上。接下来我们来实现一个简化版的<code>weight</code>吧</p><h4 id="尝试用用：实现简易版weight"><a href="#尝试用用：实现简易版weight" class="headerlink" title="尝试用用：实现简易版weight"></a>尝试用用：实现简易版weight</h4><p>为了简易起见，我们实现的<code>weight</code>有如下限制：</p><ul><li>所有子微件都有weight，按比例实现高度分配</li><li>父布局的宽高是确定的</li></ul><p>所以代码的逻辑就是：读取所有<code>weight</code>，按比例分配高度就行。</p><p>首先类似于<code>Box</code>，我们也写一个<code>VerticalScope</code>，让我们自定义的weight只能在自定义的布局中使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">VerticalScope</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">weight</span><span class="params">(weight: <span class="type">Float</span>)</span></span> : Modifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再自定义我们的<code>ParentDataModifier</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightParentData</span></span>(<span class="keyword">val</span> weight: <span class="built_in">Float</span>=<span class="number">0f</span>) : ParentDataModifier &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span> = <span class="keyword">this</span><span class="symbol">@WeightParentData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个object，让它实现我们的<code>VerticalScope</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> VerticalScopeInstance : VerticalScope &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">weight</span><span class="params">(weight: <span class="type">Float</span>)</span></span>: Modifier = <span class="keyword">this</span>.then(</span><br><span class="line">        WeightParentData(weight)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是具体的<code>Composable</code>实现了。注意，在此处，我们的<code>content</code>需要加上<code>VerticalScope.</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WeightedVerticalLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">VerticalScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>具体实现类似于之前的<code>VerticalLayout</code>，不同之处在于我们要获取到各个<code>WeightParentData</code>的值并保存下来，计算总的weight。这样就可以按比例分配高度了。</p><p>关键代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> measurePolicy = MeasurePolicy &#123; measurables, constraints -&gt;</span><br><span class="line">    <span class="keyword">val</span> placeables = measurables.map &#123;it.measure(constraints)&#125;</span><br><span class="line">    <span class="comment">// 获取各weight值</span></span><br><span class="line">    <span class="keyword">val</span> weights = measurables.map &#123;</span><br><span class="line">        (it.parentData <span class="keyword">as</span> WeightParentData).weight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> totalHeight = constraints.maxHeight</span><br><span class="line">    <span class="keyword">val</span> totalWeight = weights.sum()</span><br><span class="line">    <span class="comment">// 宽度：最宽的一项</span></span><br><span class="line">    <span class="keyword">val</span> width = placeables.maxOf &#123; it.width &#125;</span><br><span class="line"></span><br><span class="line">    layout(width, totalHeight) &#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">        placeables.forEachIndexed() &#123; i, placeable -&gt;</span><br><span class="line">            placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">            <span class="comment">// 按比例设置大小</span></span><br><span class="line">            y += (totalHeight * weights[i] / totalWeight).toInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Layout(modifier = modifier, content = &#123; VerticalScopeInstance.content() &#125;, measurePolicy=measurePolicy)</span><br></pre></td></tr></table></figure><p>测试一下？我们预备让三个Box按<code>1:2:7</code>的高度显示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WeightedVerticalLayout(Modifier.padding(<span class="number">16.</span>dp).height(<span class="number">200.</span>dp)) &#123;</span><br><span class="line">    Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">1f</span>).background(randomColor()))</span><br><span class="line">    Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">2f</span>).background(randomColor()))</span><br><span class="line">    Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">7f</span>).background(randomColor()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下，可以看到，三个Box正确按照<code>1:2:7</code>的比例显示高度</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202203101113984.png" alt="image-20220310111258869"></p><p>成功！</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>关于ParentData我们就先看这些。下一篇，我们……等我想想要写啥</p><p>本文参考：</p><ul><li><a href="https://juejin.cn/post/6964010073576177671">JetPack Compose 手写一个 Row 布局 | 自定义布局 - 掘金 (juejin.cn)</a></li><li>Android官方视频：<a href="https://www.youtube.com/watch?v=zMKMwh9gZuI">Deep dive into Jetpack Compose layouts</a></li></ul><p>本文所有代码见：<a href="https://github.com/FunnySaltyFish/JetpackComposeStudy/tree/master/app/src/main/java/com/funny/compose/study/ui/post_layout">此处</a>，欢迎star~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;https://juejin.cn/post/7068164264363556872&quot;&gt;文章&lt;/a&gt;，我们接触了固有特性测量。这一篇，我们将探索&lt;code&gt;ParentData&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;ParentData&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>深入Jetpack Compose——布局原理与自定义布局（三）</title>
    <link href="https://blog.funnysaltyfish.fun/2022/02/24/jetpack-compose-layout-3/"/>
    <id>https://blog.funnysaltyfish.fun/2022/02/24/jetpack-compose-layout-3/</id>
    <published>2022-02-24T03:47:16.000Z</published>
    <updated>2022-03-28T02:37:06.940Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇[文章](<a href="https://juejin.cn/post/7063816490021027871">深入Jetpack Compose——布局原理与自定义布局（二）</a>)中，我们探索了<code>Modifier</code>的本质和原理。这一次我们看看Compose体系中的一个重要特性：<code>固有特性测量</code>。</p><h2 id="固有特性测量"><a href="#固有特性测量" class="headerlink" title="固有特性测量"></a>固有特性测量</h2><p>或许不少人已经知道，Compose为了提高测绘性能，强行规定了每个微件只能被测量一次。也就是说，我们不能写出类似下面这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> placeables = measurables.map &#123; it.measure(constrains) &#125;</span><br><span class="line"><span class="comment">// 尝试测量第二次，直接报错</span></span><br><span class="line"><span class="keyword">val</span> placeablesSecond = measurables.map &#123; it.measure(constrains) &#125;</span><br></pre></td></tr></table></figure><h3 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h3><p>那么接下来我们看一个小例子。我们想实现一个菜单，菜单里面有几个菜单栏。于是我们写出了类似这样按的代码</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241339204.png" alt="image-20220224133926999"></p><p>但是效果不怎么样，因为每个<code>Text</code>的宽度不一样。看起来有点丑</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241340468.png" alt="image-20220224134059328"></p><p>你可能会说，要解决这个问题很简单，为每个<code>Text</code> 添加修饰符<code>fillMaxWidth</code>，让它占满即可。效果如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241342424.png" alt="image-20220224134220288"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241342785.png" alt="image-20220224134255678"></p><p>但是这样新的问题来了：由于每个<code>Text</code>的<code>Constraint</code>的<code>maxWidth</code>都是最大值，于是咱们的<code>Column</code>宽度也是最大值。于是这个菜单占满了全部屏幕空间。这可不妙！</p><p>要解决这个问题，我们只需要为<code>Column</code>添加这样一个修饰符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modifier.width(IntrinsicSize.Max)</span><br></pre></td></tr></table></figure><p>它的宽度就是子微件宽度的最大值啦</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241349842.png" alt="image-20220224134901689"></p><p>有<code>Max</code>应该就有<code>Min</code>，咱们试试？</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241351729.png" alt="image-20220224135116580"></p><p>宽度变窄了！很神奇吗？这就是固有特性测量的功劳。</p><p><em>（如果你好奇为什么最小宽度是这个，因为子微件是文本，而文本的最小宽度是它每行能容纳一个词时的宽度。在这个例子中，就是Send Feedback分成 Send \n Feedback时Feedback这行字的宽度）</em></p><p>上面的例子中，<code>Column</code>就适配了固有特性测量这一特性。接下来，我们把自己的实现的<code>VerticalLayout</code>也来适应一下（VerticalLayout具体实现见第一篇）。</p><h3 id="适配固有特性测量"><a href="#适配固有特性测量" class="headerlink" title="适配固有特性测量"></a>适配固有特性测量</h3><p>让我们重新把目光转向<code>Layout</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    measurePolicy: <span class="type">MeasurePolicy</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>之前对于第三个参数，我们是写成了SAM的形式。我们现在再来看看这个<code>MeasurePolicy</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> MeasurePolicy &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurables: <span class="type">List</span>&lt;<span class="type">Measurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MeasureResult</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The function used to calculate [IntrinsicMeasurable.minIntrinsicWidth]. It represents</span></span><br><span class="line"><span class="comment">     * the minimum width this layout can take, given a specific height, such that the content</span></span><br><span class="line"><span class="comment">     * of the layout can be painted correctly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">minIntrinsicWidth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">minIntrinsicHeight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">maxIntrinsicWidth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">maxIntrinsicHeight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        width: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>measure</code>方法是我们之前就用过的，而其余几个拓展函数就是我们要适配 <code>固有特性测量</code> 所需要重写的啦。举个栗子，使用 <code>Modifier.width(IntrinsicSize.Max)</code> ，则会调用 <code>maxIntrinsicWidth</code> 方法，其余同理。</p><p>接下来，咱们开干。先挑一个吧</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">maxIntrinsicWidth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以子微件宽度的最大值作为最大约束</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">maxIntrinsicWidth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    height: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    measurables.forEach &#123; </span><br><span class="line">        <span class="keyword">val</span> childWidth = it.maxIntrinsicWidth(height)</span><br><span class="line">        <span class="keyword">if</span>(childWidth &gt; width) width = childWidth</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241435172.png" alt="image-20220224143551073"></p><center>(宽度以单词 Funny 为标准)</center><p><strong>min</strong>的情况也差不多，效果如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202241438740.png" alt="image-20220224143833653"></p><center>(宽度以单词 is 为标准)</center><p>完整代码参见Github仓库</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>关于固有特性测量我们就先看这些。下一篇，我们将探索<code>ParentData</code>和其它特性，继续我们的布局之旅</p><p>本文参考：</p><ul><li><a href="https://juejin.cn/post/6969021972051132452">聊一聊Compose的固有特性测量Intrinsic - 掘金 (juejin.cn)</a></li><li>Android官方视频：<a href="https://www.youtube.com/watch?v=zMKMwh9gZuI">Deep dive into Jetpack Compose layouts</a></li></ul><p>本文所有代码见：<a href="https://github.com/FunnySaltyFish/JetpackComposeStudy/tree/master/app/src/main/java/com/funny/compose/study/ui/post_layout">此处</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇[文章](&lt;a href=&quot;https://juejin.cn/post/7063816490021027871&quot;&gt;深入Jetpack Compose——布局原理与自定义布局（二）&lt;/a&gt;)中，我们探索了&lt;code&gt;Modifier&lt;/code&gt;的本质和原理。这一次</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>深入Jetpack Compose——布局原理与自定义布局（二）</title>
    <link href="https://blog.funnysaltyfish.fun/2022/02/12/jetpack-compose-layout-2/"/>
    <id>https://blog.funnysaltyfish.fun/2022/02/12/jetpack-compose-layout-2/</id>
    <published>2022-02-12T13:36:16.000Z</published>
    <updated>2022-03-28T02:37:06.940Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="https://juejin.cn/post/7063451846861406245">深入Jetpack Compose——布局原理与自定义布局（一） - 掘金 (juejin.cn)</a> 中，我们大致了解了Layout过程并简单实现了两个自定义布局。本次让我们将目光转向Modifier和固有特性测量</p><p>本文部分参考自Android官方视频：<a href="https://www.youtube.com/watch?v=zMKMwh9gZuI">Deep dive into Jetpack Compose layouts</a></p><h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>关于Modifier的本质，<code>RugerMc</code>大佬在<a href="https://juejin.cn/post/6986933061845778446">图解 Modifier 实现原理 ，竟然如此简单</a>这篇文章中已经解释地非常清楚了，我就不画蛇添足了。不过为了后续行文方便，我还是在此简单说几点：</p><ol><li>Modifier 是个接口，包含三个直接实现类或接口：<code>伴生对象 Modifier</code>、内部子接口<code>Modifier.Element</code>和<code>CombinedModifier</code>。</li><li><code>伴生对象Modifier</code>是日常使用最多的，后面两者均为内部实现，实际开发中无需关注</li><li><code>Modifier.xxx()</code>方法实际上会创建一个<code>Modifier</code>接口的实现类的实例。如<code>Modifier.size()</code>会创建<code>SizeModifer</code>实例</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">size</span><span class="params">(size: <span class="type">Dp</span>)</span></span> = <span class="keyword">this</span>.then(</span><br><span class="line">    SizeModifier(</span><br><span class="line">        <span class="comment">/*省略具体细节*/</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="4"><li><p><code>Modifier.xxx().yyy().zzz()</code>实际上会创建一个Modifier链，内部顺序遵循 xxx -&gt; yyy -&gt; zzz ，由<code>CombinedModifier</code>连接。<code>Modifie接口</code>提供了<code>foldIn</code>/<code>foldOut</code>方法允许我们<code>顺序</code>/<code>逆序</code>遍历到每个Modifier</p><p>这里借上面文章中的一张图来说明：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa50641cb3364416958bf33aa848bbf4~tplv-k3u1fbpfcp-watermark.awebp" alt="来源见水印，侵删"></p></li></ol><p>我们可以简单遍历一下看看，对于下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TraverseModifier</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> modifier = Modifier</span><br><span class="line">        .size(<span class="number">40.</span>dp)</span><br><span class="line">        .background(Color.Gray)</span><br><span class="line">        .clip(CircleShape)</span><br><span class="line">    LaunchedEffect(modifier)&#123;</span><br><span class="line">        <span class="comment">// 顺序遍历Modifier</span></span><br><span class="line">        modifier.foldIn(<span class="number">0</span>)&#123; index , element : Modifier.Element -&gt;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;<span class="variable">$index</span> -&gt; <span class="variable">$element</span>&quot;</span>)</span><br><span class="line">            index + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的输出为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 -&gt; androidx.compose.foundation.layout.SizeModifier@78000000</span><br><span class="line">1 -&gt; Background(color=Color(...), brush=null, alpha = 1.0, shape=RectangleShape)</span><br><span class="line">2 -&gt; SimpleGraphicsLayerModifier(...)</span><br></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>接下来，我们看看Modifier是怎么在布局中起作用的</p><p>先看一个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ModifierSample1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 父元素</span></span><br><span class="line">    Box(modifier = Modifier</span><br><span class="line">        .width(<span class="number">200.</span>dp)</span><br><span class="line">        .height(<span class="number">300.</span>dp)</span><br><span class="line">        .background(Color.Yellow))&#123;</span><br><span class="line">        <span class="comment">// 子元素</span></span><br><span class="line">        Box(modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .wrapContentSize(align = Alignment.Center)</span><br><span class="line">            .size(<span class="number">50.</span>dp)</span><br><span class="line">            .background(Color.Blue))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它实际显示的效果如下</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202121752667.png" alt="左上角的圆角是屏幕边缘"></p><center><small>（左上角的圆角是屏幕边缘）</small></center><p>我们来逐步看看这到底是怎么发生的。这里我们选择子元素，也就是那个小一点的蓝色Box，来看看它的<strong>measure</strong>和<strong>place</strong>过程。</p><p>首先是<strong>measure</strong>。父元素明确了自身大小为200*300，该大小也就是子元素能占据的最大空间。因此</p><ol><li><p>初始：初始约束 <strong>w:0-200, h:0-300</strong></p></li><li><p>fillMaxSize()：占据最大空间，约束的<code>min</code>值更改为与<code>max</code>相同，即 <strong>w:200-200, h:300-300</strong></p></li><li><p>wrapContentSize()：适应内容大小，约束的<code>min</code>值重新变回了0，即 <strong>w:0-200, h:0-300</strong></p></li><li><p>size()：指定了精准大小。约束变为 <strong>w:50-50, h:50-50</strong></p></li><li><p>background()：对大小约束无影响</p></li></ol><p>最后，在<code>Modifier</code>的一顿操作之下，Box会收到一个 <strong>w:50-50, h:50-50</strong> 的约束。到这里走过的状态如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202121806531.png" alt="image-20220212180649407"></p><p>接下来，Box内部的<code>Layout</code>微件执行<strong>measure</strong>方法得到了自己的大小：*<em>50</em>50<strong>。这个大小</strong>反向传回到Modifier链的最后一项，并开始place**。接下来：</p><ol><li>background()：此处略过</li><li>size(50.dp)：测得自己的大小：50*50，并据此创建自己的位置指令</li><li>wrapContentSize()：测得自己的大小：200<em>300，并知道自己的子元素大小50\</em>50，且居中放置。据此创建自己的位置指令。</li><li>fillMaxSize()：解析自己的大小和位置</li></ol><p>这个过程很类似于<code>Layout</code>微件，区别就是<strong>每个Modifier只有一个子元素</strong>（也就是Modifier链上的下一个元素）。事实上，如果看代码，你也很容易感受到二者的相似之处</p><p>拿<code>wrapContentSize</code>修饰符的代码举例，其实现类<code>WrapContentModifier</code>的<code>measure</code>方法如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MeasureResult &#123;</span><br><span class="line">    <span class="comment">// 设置约束</span></span><br><span class="line">    <span class="keyword">val</span> wrappedConstraints = Constraints(<span class="comment">/**/)</span></span><br><span class="line"><span class="comment">    // 测量得到可放置项</span></span><br><span class="line"><span class="comment">    val placeable = measurable.measure(wrappedConstraints)</span></span><br><span class="line"><span class="comment">    val wrapperWidth = placeable.width.coerceIn(constraints.minWidth, constraints.maxWidth)</span></span><br><span class="line"><span class="comment">    val wrapperHeight = placeable.height.coerceIn(constraints.minHeight, constraints.maxHeight)</span></span><br><span class="line"><span class="comment">    // layout函数放置到指定位置并返回结果</span></span><br><span class="line"><span class="comment">    return layout(</span></span><br><span class="line"><span class="comment">        wrapperWidth,</span></span><br><span class="line"><span class="comment">        wrapperHeight</span></span><br><span class="line"><span class="comment">    ) &#123;</span></span><br><span class="line"><span class="comment">        val position = alignmentCallback(</span></span><br><span class="line"><span class="comment">            IntSize(wrapperWidth - placeable.width, wrapperHeight - placeable.height),</span></span><br><span class="line"><span class="comment">            layoutDirection</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment">        placeable.place(position)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>怎么样，是不是很相似？</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>关于Modifier我们就先看这些。下一篇，我们将接触<code>固有特性测量</code>这一特性，并改进我们在第一篇文章中实现的纵向布局。</p><p>本文所有代码见：<a href="https://github.com/FunnySaltyFish/JetpackComposeStudy/tree/master/app/src/main/java/com/funny/compose/study/ui/post_layout">此处</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇文章&lt;a href=&quot;https://juejin.cn/post/7063451846861406245&quot;&gt;深入Jetpack Compose——布局原理与自定义布局（一） - 掘金 (juejin.cn)&lt;/a&gt; 中，我们大致了解了Layout过程并简单实现了两</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>深入Jetpack Compose——布局原理与自定义布局（一）</title>
    <link href="https://blog.funnysaltyfish.fun/2022/02/12/jetpack-compose-layout-1/"/>
    <id>https://blog.funnysaltyfish.fun/2022/02/12/jetpack-compose-layout-1/</id>
    <published>2022-02-12T03:47:16.000Z</published>
    <updated>2022-03-28T02:37:06.938Z</updated>
    
    <content type="html"><![CDATA[<p>Jetpack Compose 正式版发布也已半年了，对我来说，应用到项目中也很久了<small>（参见本人开源项目：<a href="https://github.com/FunnySaltyFish/FunnyTranslation">译站</a>）</small>。 目前很多文章还集中于初探上，因此萌生了写作本文的想法，算是为Compose中文资料提供绵薄之力。</p><p>本文的内容来自Android官方视频：<a href="https://www.youtube.com/watch?v=zMKMwh9gZuI">Deep dive into Jetpack Compose layouts</a></p><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>Jetpack Compose 中，单个可组合项被显示出来，总体上经历三个过程</p><p><strong>Composition（组合） -&gt; Layout（布局） -&gt; Drawing（绘制）</strong> ，其中Layout阶段又存在两个方面的内容：<strong>Measure（测量） 和 Place（摆放）</strong></p><p>今天我们主要着眼于 Layout 阶段，看看各个 Composable 是如何正确确定各自位置和大小的</p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>Layout阶段主要做三件事情：</p><ol><li>测量所有子微件的大小</li><li>确定自己的大小</li><li>正确摆放所有子元素的位置</li></ol><p>为简化说明，我们先给出一个简单例子。该例子中，所有元素只需要遍历一次。</p><p>如下图的 <code>SearchResult</code>微件，它的构成如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111712123.png" alt="image-20220211171231994"></p><p>现在我们来看看Layout过程在这个例子中是什么情况</p><h4 id="Measure"><a href="#Measure" class="headerlink" title="Measure"></a>Measure</h4><ol><li>请求测量根布局，即<code>Row</code></li></ol><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111715804.png" alt="image-20220211171509751" style="zoom:50%;" /><ol start="2"><li><p><code>Row</code>为了知道自己的大小，就得先知道自己的子微件有多大，于是请求<code>Image</code>和<code>Column</code>测量它们自己</p><ol><li>对于<code>Image</code>，由于它内部没有其他微件，所以它可以完成自身测量过程并返回相关位置指令</li></ol><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111717527.png" alt="image-20220211171746467" style="zoom: 50%;" /><ol start="2"><li>接下来是<code>Column</code>，因为它内部有两个<code>Text</code>，于是请求子微件测量。而对于<code>Text</code>，它们也会正确返回自己的大小和位置指令</li></ol><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111719907.png" alt="image-20220211171934824" style="zoom:50%;" /><ol start="3"><li>这时 Column 大小和位置指令即可正确确定</li></ol></li><li><p>最后，<code>Row</code>内部所有测量完成，它可以正确获得自己的大小和位置指令</p></li></ol><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111721514.png" alt="image-20220211172155426" style="zoom:50%;" /><p>测量阶段到此结束，接下来就是正确的摆放位置了</p><h4 id="Place"><a href="#Place" class="headerlink" title="Place"></a>Place</h4><p>完成测量后，微件就可以根据自身大小<strong>从上至下</strong>执行各子微件的位置指令，从而确定每个微件的正确位置</p><p>现在我们把目光转向Composition阶段。大家平时写微件，内部都是由很多更基本的微件组合而来的，而事实上，这些基本的微件还有更底层的组成部分。如果我们展开刚刚的那个例子，它就成了这个样子</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111728631.png" alt="image-20220211172838557" style="zoom:50%;" /><p>在这里，所有的叶节点<small>(即没有子元素的节点)</small>都是<code>Layout</code>这个微件</p><p>我们来看看这个微件吧</p><h3 id="Layout-Composable"><a href="#Layout-Composable" class="headerlink" title="Layout Composable"></a>Layout Composable</h3><p>此微件的签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    measurePolicy: <span class="type">MeasurePolicy</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>我们先看看第三个参数，这是之前从未见过的东西；而它恰恰控制着如何确定微件大小以及它们的摆放策略</p><p>那来写个例子吧。我们现在自定义一个简单的纵向布局，也就是低配版Column</p><h4 id="自定义布局-纵向布局"><a href="#自定义布局-纵向布局" class="headerlink" title="自定义布局 - 纵向布局"></a>自定义布局 - 纵向布局</h4><p>写个框架</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">VerticalLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = content</span><br><span class="line">    ) &#123; measurables: List&lt;Measurable&gt;, constrains: Constraints -&gt;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Measurable</code>代表可测量的，其定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Measurable</span> : <span class="type">IntrinsicMeasurable &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Measures the layout with [constraints], returning a [Placeable] layout that has its new</span></span><br><span class="line"><span class="comment">     * size. A [Measurable] can only be measured once inside a layout pass.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: Placeable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这是个接口，唯一的方法<code>measure</code>返回<code>Placeable</code>，接下来根据这个Placeable摆放位置。而参数measurables其实也就是传入的子微件形成的列表</p><p>而<code>Constraints</code>则描述了微件的大小策略，它的部分定义摘录如下：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111748748.png" alt="image-20220211174814661" style="zoom:50%;" /><p>举个栗子，如果我们想让这个微件想多大就多大（类似match_parent），那我们可以这样写：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111749649.png" alt="image-20220211174939592" style="zoom:50%;" /><p>如果它是固定大小（比如长宽50），那就是这样写</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111750399.png" alt="image-20220211175028341" style="zoom:50%;" /><p>接下来我们就先获取placeable吧</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> placeables = measurables.map &#123; it.measure(constrains) &#125;</span><br></pre></td></tr></table></figure><p>在这个简单的例子中，我们不对measure的过程进行过多干预，直接测完获得有大小的可放置项</p><p>接下来确定我们的<code>VerticalLayout</code>的宽、高。对于咱们的布局，它的宽应该容纳的下最宽的孩子，高应该是所有孩子之和。于是得到以下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽度：最宽的一项</span></span><br><span class="line"><span class="keyword">val</span> width = placeables.maxOf &#123; it.width &#125;</span><br><span class="line"><span class="comment">// 高度：所有子微件高度之和</span></span><br><span class="line"><span class="keyword">val</span> height = placeables.sumOf &#123; it.height &#125;</span><br></pre></td></tr></table></figure><p>最后，我们调用<code>layout</code>方法返回最终的测量结果。前两个参数为自身的宽高，第三个lambda确定每个Placeable的位置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout(width, height)&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">    placeables.forEach &#123;</span><br><span class="line">        it.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">        y += it.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了<code>Placeable.placeRelative</code>方法，它能够正确处理从右到左布局的镜像转换</p><p>一个简单的Column就写好了。试一下？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">randomColor</span><span class="params">()</span></span> = Color(Random.nextInt(<span class="number">255</span>),Random.nextInt(<span class="number">255</span>),Random.nextInt(<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomLayoutTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    VerticalLayout() &#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.5</span>).forEach &#123;</span><br><span class="line">            Box(modifier = Modifier.size(<span class="number">40.</span>dp).background(randomColor()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202111817149.png" alt="image-20220211181720062" style="zoom:50%;" /><p>嗯，工作基本正常。</p><p>接下来我们实现一个更复杂一点的：简易瀑布流</p><h4 id="自定义布局—简易瀑布流"><a href="#自定义布局—简易瀑布流" class="headerlink" title="自定义布局—简易瀑布流"></a>自定义布局—简易瀑布流</h4><p>先把基本的框架撸出来，在这里只实现纵向的，横向同理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterfallFlowLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> ()-&gt;<span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    columns: <span class="type">Int</span> = <span class="number">2</span>  <span class="comment">// 横向几列 </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = content,</span><br><span class="line">    ) &#123; measurables: List&lt;Measurable&gt;, constrains: Constraints -&gt;</span><br><span class="line">        TODO()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们加入了参数<code>columns</code>用来指定有几列。由于瀑布流宽度是确定的，所以我们需要手动指定宽度</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> itemWidth = constrains.maxWidth / <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> itemConstraints = constrains.copy(minWidth = itemWidth, maxWidth = itemWidth)</span><br><span class="line"><span class="keyword">val</span> placeables = measurables.map &#123; it.measure(itemConstraints) &#125;</span><br></pre></td></tr></table></figure><p>在这里我们用新的 <code>itemConstraints</code> 对子微件的大小进行约束，固定了子微件的宽度</p><p>接下来就是摆放了。瀑布流的摆放方式其实就是看看当前哪一列最矮，就把当前微件摆到哪一列，不断重复就行</p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterfallFlowLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    columns: <span class="type">Int</span> = <span class="number">2</span>,  <span class="comment">// 横向几列</span></span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> ()-&gt;<span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = content,</span><br><span class="line">    ) &#123; measurables: List&lt;Measurable&gt;, constrains: Constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> itemWidth = constrains.maxWidth / columns</span><br><span class="line">        <span class="keyword">val</span> itemConstraints = constrains.copy(minWidth = itemWidth, maxWidth = itemWidth)</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(itemConstraints) &#125;</span><br><span class="line">        <span class="comment">// 记录当前各列高度</span></span><br><span class="line">        <span class="keyword">val</span> heights = IntArray(columns)</span><br><span class="line">        layout(width = constrains.maxWidth, height = constrains.maxHeight)&#123;</span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                <span class="keyword">val</span> minIndex = heights.minIndex()</span><br><span class="line">                placeable.placeRelative(itemWidth * minIndex, heights[minIndex])</span><br><span class="line">                heights[minIndex] += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了一个自定义的拓展函数<code>minIndex</code>，作用是寻找<strong>数组中最小项的索引值</strong>，代码很简单，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> IntArray.<span class="title">minIndex</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> min = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">    <span class="keyword">this</span>.forEachIndexed &#123; index, e -&gt;</span><br><span class="line">        <span class="keyword">if</span> (e&lt;min)&#123;</span><br><span class="line">            min = e</span><br><span class="line">            i = index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下（设置列数为3）：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202202112149060.png" alt="image-20220211214931940" style="zoom:50%;" /><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>本文所有代码见：<a href="https://github.com/FunnySaltyFish/JetpackComposeStudy/tree/master/app/src/main/java/com/funny/compose/study/ui/post_layout">此处</a></p><p>现在的布局只是简单情况，然而事实上，很多时候往往涉及到其他内容。Modifier 的奥秘也等待我们进一步探索。再叙。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Jetpack Compose 正式版发布也已半年了，对我来说，应用到项目中也很久了&lt;small&gt;（参见本人开源项目：&lt;a href=&quot;https://github.com/FunnySaltyFish/FunnyTranslation&quot;&gt;译站&lt;/a&gt;）&lt;/small&gt;。 </summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 中优雅完成数据持久化</title>
    <link href="https://blog.funnysaltyfish.fun/2022/01/25/jetpack-compose-data-saver/"/>
    <id>https://blog.funnysaltyfish.fun/2022/01/25/jetpack-compose-data-saver/</id>
    <published>2022-01-25T09:38:56.000Z</published>
    <updated>2022-02-12T03:51:47.355Z</updated>
    
    <content type="html"><![CDATA[<p>Compose出来也好久了，各种remember和LocalXXX.current也是用得越来越熟。如果能在保持上述写法一致性的情况下完成数据的持久化工作，不是显得挺优雅的吗？<br>基于此，我写出了开源库：<a href="https://github.com/FunnySaltyFish/ComposeDataSaver">ComposeDataSaver: 在Jetpack Compose中优雅完成数据持久化</a><br>简单一瞥：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// booleanExample 初始化值为false</span></span><br><span class="line"><span class="comment">// 之后会自动读取本地数据</span></span><br><span class="line"><span class="keyword">var</span> booleanExample <span class="keyword">by</span> rememberDataSaverState(KEY_BOOLEAN_EXAMPLE, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 直接赋值即可完成持久化</span></span><br><span class="line">booleanExample = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可还行？</p><h1 id="ComposeDataSaver"><a href="#ComposeDataSaver" class="headerlink" title="ComposeDataSaver"></a>ComposeDataSaver</h1><p>项目有以下特点：</p><ul><li>  简洁：近似原生的写法</li><li>  低耦合：抽象接口，不限制底层保存算法实现</li><li>  轻巧：默认不引入除Compose外任何第三方库</li><li>  灵活：支持基本的数据类型和自定义类型</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aa3a9c8ae9c4143a84141a36cbd4532~tplv-k3u1fbpfcp-zoom-1.image" alt="Example"></p><hr><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在<code>settings.gradle</code>引入jitpack仓库位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目<code>build.gradle</code>引入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        implementation <span class="string">&#x27;com.github.FunnySaltyFish.ComposeDataSaver:data-saver:v1.0.2</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>项目使用<code>DataSaverInterface</code>接口的实现类来保存数据，因此您需要先提供一个此类对象。</p><p>项目默认包含了使用<code>Preference</code>保存数据的实现类<code>DataSaverPreferences</code>，可如下初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init preferences</span></span><br><span class="line"><span class="keyword">val</span> dataSaverPreferences = DataSaverPreferences().apply &#123;</span><br><span class="line">    setContext(context = applicationContext)</span><br><span class="line">&#125;</span><br><span class="line">CompositionLocalProvider(LocalDataSaver provides dataSaverPreferences)&#123;</span><br><span class="line">    ExampleComposable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后在<code>ExampleComposable</code>及其子微件内部可使用<code>LocalDataSaver.current</code>获取当前实例</p><p>对于基本数据类型（如String/Int/Boolean）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// booleanExample 初始化值为false</span></span><br><span class="line"><span class="comment">// 之后会自动读取本地数据</span></span><br><span class="line"><span class="keyword">var</span> booleanExample <span class="keyword">by</span> rememberDataSaverState(KEY_BOOLEAN_EXAMPLE, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 直接赋值即可完成持久化</span></span><br><span class="line">booleanExample = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>就这么简单！</p><h2 id="自定义存储框架"><a href="#自定义存储框架" class="headerlink" title="自定义存储框架"></a>自定义存储框架</h2><p>我们提供了基于 <a href="https://github.com/Tencent/MMKV">MMKV</a> 或者 <a href="https://developer.android.google.cn/jetpack/androidx/releases/datastore">DataStorePreference</a> 的简单实现</p><h3 id="MMKV"><a href="#MMKV" class="headerlink" title="MMKV"></a>MMKV</h3><ol><li>在上述依赖基础上，额外添加</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">if</span> you want to use mmkv</span><br><span class="line">implementation <span class="string">&quot;com.github.FunnySaltyFish.ComposeDataSaver:data-saver-mmkv:v1.0.2&quot;</span></span><br><span class="line">implementation <span class="string">&#x27;com.tencent:mmkv:1.2.12&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如下初始化</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MMKV.initialize(applicationContext)</span><br><span class="line"><span class="keyword">val</span> dataSaverMMKV = DataSaverMMKV().apply &#123;</span><br><span class="line">    setKV(newKV = MMKV.defaultMMKV())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CompositionLocalProvider(LocalDataSaver provides dataSaverMMKV)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="DataStorePreference"><a href="#DataStorePreference" class="headerlink" title="DataStorePreference"></a>DataStorePreference</h3><ol><li>在上述依赖基础上，额外添加</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">if</span> you want to use DataStore</span><br><span class="line">implementation <span class="string">&quot;com.github.FunnySaltyFish.ComposeDataSaver:data-saver-data-store-preferences:v1.0.2&quot;</span></span><br><span class="line">def data_store_version = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.datastore:datastore:<span class="variable">$data_store_version</span>&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.datastore:datastore-preferences:<span class="variable">$data_store_version</span>&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如下初始化</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Context.dataStore : DataStore&lt;Preferences&gt; <span class="keyword">by</span> preferencesDataStore(<span class="string">&quot;dataStore&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> dataSaverDataStorePreferences = DataSaverDataStorePreferences().apply &#123;</span><br><span class="line">    setDataStorePreferences(applicationContext.dataStore)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CompositionLocalProvider(LocalDataSaver provides dataSaverDataStorePreferences)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="其他存储框架"><a href="#其他存储框架" class="headerlink" title="其他存储框架"></a>其他存储框架</h3><p>只需要实现<code>DataSaverInterface</code>类，并重写<code>saveData</code>和<code>readData</code>方法分别用于保存数据和读取数据</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DataSaverInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">saveData</span><span class="params">(key:<span class="type">String</span>, <span class="keyword">data</span> : <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">readData</span><span class="params">(key: <span class="type">String</span>, default : <span class="type">T</span>)</span></span> : T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将LocalDataSaver提供的对象更改为您自己的类实例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataStore = DataSaverDataStore()</span><br><span class="line">CompositionLocalProvider(LocalDataSaver provides dataStore)&#123;</span><br><span class="line">    ExampleComposable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续相同使用即可。</p><h2 id="保存自定义类型"><a href="#保存自定义类型" class="headerlink" title="保存自定义类型"></a>保存自定义类型</h2><p>默认的<code>DataSaverPreferences</code>并不提供自定义类型的保存（当尝试这样做时会报错）。尽管不建议持久化实体类，但您仍可以这样做。您可以选择以下方式实现这一目标。</p><ol><li>重写自己的<code>DataSaverInterface</code>实现类（见上）并实现相关的保存方法</li><li>将实体类序列化为其他基本类型（如String）再储存</li></ol><p>对于第二种方式，您需要为对应实体类添加转换器以实现保存时自动转换为String。方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>(<span class="keyword">var</span> id:<span class="built_in">Int</span>, <span class="keyword">val</span> label:String)</span><br><span class="line"><span class="comment">// ------------ //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在初始化时调用registerTypeConverters方法注册对应转换方法</span></span><br><span class="line"><span class="comment">// 该方法接收两个参数：实体类Class和对应的转换方法（Lambda表达式）</span></span><br><span class="line">registerTypeConverters(ExampleBean::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">    <span class="keyword">val</span> bean = it <span class="keyword">as</span> ExampleBean</span><br><span class="line">    Json.encodeToString(bean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整例子见<a href="/app/src/main/java/com/funny/composedatasaver/ExampleActivity.kt">示例项目</a></p><h2 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h2><ol><li>如果在某些情况下你不想频繁持久化保存，可设置<code>rememberDataSaverState</code>的<code>autoSave</code>参数为<code>false</code>，此时对象的赋值操作将不会执行持久化操作，您在需要保存的位置手动保存：<code>LocalDataSaver.current.saveData()</code></li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>新项目，希望大家喜欢。觉得好用不妨来个Star？！<br>虎年快到了，提前祝各位万事顺利、虎虎生风！<br>最后复读一下地址：<a href="https://github.com/FunnySaltyFish/ComposeDataSaver">FunnySaltyFish/ComposeDataSaver: 在Jetpack Compose中优雅完成数据持久化 (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Compose出来也好久了，各种remember和LocalXXX.current也是用得越来越熟。如果能在保持上述写法一致性的情况下完成数据的持久化工作，不是显得挺优雅的吗？&lt;br&gt;基于此，我写出了开源库：&lt;a href=&quot;https://github.com/Funny</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose LazyColumn列表项动画</title>
    <link href="https://blog.funnysaltyfish.fun/2021/12/23/jetpack-compose-lazy-column-item-anim/"/>
    <id>https://blog.funnysaltyfish.fun/2021/12/23/jetpack-compose-lazy-column-item-anim/</id>
    <published>2021-12-23T03:13:59.000Z</published>
    <updated>2022-03-28T02:37:06.940Z</updated>
    
    <content type="html"><![CDATA[<p>具体包括：列表项数据顺序变更时的轮换动画、添加/删除列表项时的小动画、侧滑删除动画</p><p>不废话，本文主要介绍的就是一个修饰符：<code>Modifier.animateItemPlacement()</code>。该修饰符首次出现于Jetpack Compose <strong>1.1.0-beta03</strong>版本（此版本于2021年11月17日发布），目前尚处于试验性阶段。但它能实现的效果是非常有趣的。</p><h3 id="顺序变更-动画"><a href="#顺序变更-动画" class="headerlink" title="顺序变更 动画"></a>顺序变更 动画</h3><p>简单看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list <span class="keyword">by</span> remember &#123; mutableStateOf(listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>)) &#125;</span><br><span class="line">  LazyColumn &#123;</span><br><span class="line">      item &#123;</span><br><span class="line">          Button(onClick = &#123; list = list.shuffled() &#125;) &#123;</span><br><span class="line">              Text(<span class="string">&quot;打乱顺序&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      items(items = list, key = &#123; it &#125;) &#123;</span><br><span class="line">          Text(<span class="string">&quot;列表项：<span class="variable">$it</span>&quot;</span>, Modifier.animateItemPlacement())</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202112181030545.gif" alt="Jetpack Compose-shuffle"></p><p>实现此效果如此简单！</p><h3 id="侧滑删除动画"><a href="#侧滑删除动画" class="headerlink" title="侧滑删除动画"></a>侧滑删除动画</h3><p>在Jetpack Compose中，实现侧滑删除需要用到<code>SwipeToDismiss</code>微件</p><p>简单例子如下：</p><p><em>数据类：</em></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> id:<span class="built_in">Int</span>, <span class="keyword">val</span> name:String)</span><br></pre></td></tr></table></figure><p><em>微件</em></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentList <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf( (<span class="number">1.</span><span class="number">.100</span>).map &#123; Student(it, <span class="string">&quot;Student <span class="variable">$it</span>&quot;</span>) &#125; )</span><br><span class="line">    &#125;</span><br><span class="line">    LazyColumn(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        verticalArrangement = Arrangement.spacedBy(<span class="number">8.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        items(studentList, key = &#123;item: Student -&gt; item.id &#125;)&#123; item -&gt;</span><br><span class="line">            <span class="comment">// 侧滑删除所需State</span></span><br><span class="line">            <span class="keyword">val</span> dismissState = rememberDismissState()</span><br><span class="line">            <span class="comment">// 按指定方向触发删除后的回调，在此处变更具体数据</span></span><br><span class="line">            <span class="keyword">if</span>(dismissState.isDismissed(DismissDirection.StartToEnd))&#123;</span><br><span class="line">                studentList = studentList.toMutableList().also &#123;  it.remove(item) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SwipeToDismiss(</span><br><span class="line">                state = dismissState,</span><br><span class="line">                <span class="comment">// animateItemPlacement() 此修饰符便添加了动画</span></span><br><span class="line">                modifier = Modifier.fillMaxWidth().animateItemPlacement(),</span><br><span class="line">                <span class="comment">// 下面这个参数为触发滑动删除的移动阈值</span></span><br><span class="line">                dismissThresholds = &#123; direction -&gt;</span><br><span class="line">                    FractionalThreshold(<span class="keyword">if</span> (direction == DismissDirection.StartToEnd) <span class="number">0.25f</span> <span class="keyword">else</span> <span class="number">0.5f</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 允许滑动删除的方向</span></span><br><span class="line">                directions = setOf(DismissDirection.StartToEnd),</span><br><span class="line">                <span class="comment">// &quot;背景 &quot;，即原来显示的内容被划走一部分时显示什么</span></span><br><span class="line">                background = &#123;</span><br><span class="line">                    <span class="comment">/*保证观看体验，暂时省略此处内容*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// ”前景“ 显示的内容</span></span><br><span class="line">                <span class="comment">/*省略一部分不重要修饰*/</span></span><br><span class="line">                Text(item.name, Modifier.padding(<span class="number">8.</span>dp), fontSize = <span class="number">28.</span>sp)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202112181049286.gif" alt="Jetpack Compose-swipeToDismiss"></p><p><em>上述代码来自于 <a href="https://stackoverflow.com/questions/70066048/swipetodismiss-inside-lazycolumn-with-animation/70073933#70073933">android - SwipeToDismiss inside LazyColumn with animation - Stack Overflow</a></em></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>animateItemPlacement</code>修饰符仅在LazyColumn和LazyRow中有效，并且必须<strong>指定key</strong>参数。除重排外，由更改<code>alignment</code>或者<code>arrangement</code>引起的位置改变也会被添加动画。</p><p>此修饰符有一个可选参数：<code>animationSpec: FiniteAnimationSpec&lt;IntOffset&gt;</code>，你可以修改此参数以更改动画效果。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这篇文章其实很早之前就想写了，但是一直拖到现在。其实文章写的东西说白了就是介绍个API，但是这个API很有用，而且目前也没有中文资料，于是我就写了。做点自己的贡献吧。</p><p>文章所有代码均可在<a href="https://github.com/FunnySaltyFish/JetpackComposeStudy/tree/master/app/src/main/java/com/funny/compose/study/ui/posta">此处</a>找到，除上述提到的还放了一个Google的官方例子。有兴趣的可以看看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;具体包括：列表项数据顺序变更时的轮换动画、添加/删除列表项时的小动画、侧滑删除动画&lt;/p&gt;
&lt;p&gt;不废话，本文主要介绍的就是一个修饰符：&lt;code&gt;Modifier.animateItemPlacement()&lt;/code&gt;。该修饰符首次出现于Jetpack Compose</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 通用加载微件的实现</title>
    <link href="https://blog.funnysaltyfish.fun/2021/12/23/jetpack-compose-loading-widget/"/>
    <id>https://blog.funnysaltyfish.fun/2021/12/23/jetpack-compose-loading-widget/</id>
    <published>2021-12-23T03:10:07.000Z</published>
    <updated>2021-12-23T03:13:20.456Z</updated>
    
    <content type="html"><![CDATA[<p>加载数据在Android开发中应该算是非常频繁的操作了，因此简单在Jetpack Compose中实现一个通用的加载微件</p><p>效果如下：</p><p><strong>加载中（转圈圈）</strong></p><table><thead><tr><th>加载中</th><th>加载完成</th></tr></thead><tbody><tr><td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfe7e51a5b5d4cf4b24f75246def758d~tplv-k3u1fbpfcp-zoom-1.image"></td><td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ef0a17ff4f47bb85222d3c08b88295~tplv-k3u1fbpfcp-zoom-1.image"></td></tr></tbody></table><p>另外加载失败后显示失败并可以点击重试</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66aa4f07ba6f49d7893431ec23f8a814~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现这个微件其实非常简单，无非就是根据不同的状态加载不同页面</p><h5 id="加载状态Bean"><a href="#加载状态Bean" class="headerlink" title="加载状态Bean"></a>加载状态Bean</h5><p>首先把加载的状态抽象出来，写个数据类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> sealed class LoadingState&lt;out R&gt; &#123;</span><br><span class="line">     object Loading : LoadingState&lt;Nothing&gt;()</span><br><span class="line">     data class Failure(val error : Throwable) : LoadingState&lt;Nothing&gt;()</span><br><span class="line">     data class Success&lt;T&gt;(val data : T) : LoadingState&lt;T&gt;()</span><br><span class="line"> ​</span><br><span class="line">     val isLoading</span><br><span class="line">         get() = this is Loading</span><br><span class="line">     val isSuccess</span><br><span class="line">         get() = this is Success&lt;*&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此处借鉴了朱江大佬写的玩安卓Compose版本，在此感谢</p><h5 id="微件"><a href="#微件" class="headerlink" title="微件"></a>微件</h5><p>然后就是加载了。考虑到加载一般耗时，所以用协程。</p><p>写成微件大概就是下面这个样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> private const val TAG = &quot;LoadingWidget&quot;</span><br><span class="line"> ​</span><br><span class="line"> /**</span><br><span class="line">  * 通用加载微件</span><br><span class="line">  * @author [FunnySaltyFish](https://blog.funnysaltyfish.fun/)</span><br><span class="line">  * @param modifier Modifier 整个微件包围在Box中，此处修饰此Box</span><br><span class="line">  * @param loader  加载函数，返回值为正常加载出的结果</span><br><span class="line">  * @param loading 加载中显示的页面，默认为转圈圈</span><br><span class="line">  * @param failure 加载失败显示的页面，默认为文本，点击可以重新加载（retry即为重新加载的函数）</span><br><span class="line">  * @param success 加载成功后的页面，参数[T]即为返回的结果</span><br><span class="line">  */</span><br><span class="line"> @Composable</span><br><span class="line"> fun &lt;T&gt; LoadingContent(</span><br><span class="line">     modifier: Modifier = Modifier,</span><br><span class="line">     loader : suspend ()-&gt;T,</span><br><span class="line">     loading : @Composable ()-&gt;Unit = &#123; DefaultLoading() &#125;,</span><br><span class="line">     failure : @Composable (error : Throwable, retry : ()-&gt;Unit)-&gt;Unit = &#123; error, retry-&gt;</span><br><span class="line">         DefaultFailure(error, retry)</span><br><span class="line">     &#125;,</span><br><span class="line">     success : @Composable (data : T?)-&gt;Unit</span><br><span class="line"> ) &#123;</span><br><span class="line">     var key by remember &#123;</span><br><span class="line">         mutableStateOf(false)</span><br><span class="line">     &#125;</span><br><span class="line">     val state : LoadingState&lt;T&gt; by produceState&lt;LoadingState&lt;T&gt;&gt;(initialValue = LoadingState.Loading, key)&#123;</span><br><span class="line">         value = try &#123;</span><br><span class="line">             Log.d(TAG, &quot;LoadingContent: loading...&quot;)</span><br><span class="line">             LoadingState.Success(loader())</span><br><span class="line">         &#125;catch (e: Exception)&#123;</span><br><span class="line">             LoadingState.Failure(e)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     Box(modifier = modifier)&#123;</span><br><span class="line">         when(state)&#123;</span><br><span class="line">             is LoadingState.Loading -&gt; loading()</span><br><span class="line">             is LoadingState.Success&lt;T&gt; -&gt; success((state as LoadingState.Success&lt;T&gt;).data)</span><br><span class="line">             is LoadingState.Failure -&gt; failure((state as LoadingState.Failure).error)&#123;</span><br><span class="line">                 key = !key</span><br><span class="line">                 Log.d(TAG, &quot;LoadingContent: newKey:$key&quot;)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>基于produceState加载并保存数据，然后根据不同的加载状态显示不同的页面。<br>官方对此函数的翻译如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an observable [snapshot][androidx.compose.runtime.snapshots.Snapshot] [State] that</span></span><br><span class="line"><span class="comment"> * produces values over time from [key1].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [producer] is launched when [produceState] enters the composition and is cancelled when</span></span><br><span class="line"><span class="comment"> * [produceState] leaves the composition. If [key1] changes, a running [producer] will be</span></span><br><span class="line"><span class="comment"> * cancelled and re-launched for the new source. [producer] should use [ProduceStateScope.value]</span></span><br><span class="line"><span class="comment"> * to set new values on the returned [State].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The returned [State] conflates values; no change will be observable if</span></span><br><span class="line"><span class="comment"> * [ProduceStateScope.value] is used to set a value that is [equal][Any.equals] to its old value,</span></span><br><span class="line"><span class="comment"> * and observers may only see the latest value if several values are set in rapid succession.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [produceState] may be used to observe either suspending or non-suspending sources of external</span></span><br><span class="line"><span class="comment"> * data, for example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> androidx.compose.runtime.samples.ProduceState</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> androidx.compose.runtime.samples.ProduceStateAwaitDispose</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个可观察的[snapshot][androidx.compose.runtime.snapshots.Snapshot] [State] 对象，它的值由[key1]随时间变化产生.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [producer] 在 [produceState] 进入 composition 后会被启动，当[produceState] 离开 composition 时被取消. 如果 [key1] 改变, 当前正在运行的 [producer] 将被取消并根据新来源重启. </span></span><br><span class="line"><span class="comment"> * [producer] 应当使用 [ProduceStateScope.value] ，在返回的 [State] 中设置 value 的值.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回的 [State] 与 value 一致; 如若新的值与旧value相等[Any.equals] ，则此变化不会被观察到</span></span><br><span class="line"><span class="comment"> * 如果在短时间内多个新值被赋予，则观察着可能仅能观察到最新的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [produceState] 可被用在 suspending / non-suspending 的外部数据来源中，如:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> androidx.compose.runtime.samples.ProduceState</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> androidx.compose.runtime.samples.ProduceStateAwaitDispose</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>除开数据加载外，上面的代码也给出了几个默认页面。分别有默认的加载页面（转圈圈）和默认的错误页面（点击重试）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> @Composable</span><br><span class="line"> fun DefaultLoading() &#123;</span><br><span class="line">     CircularProgressIndicator()</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> @Composable</span><br><span class="line"> fun DefaultFailure(error: Throwable, retry : ()-&gt;Unit) &#123;</span><br><span class="line">     Text(text = stringResource(id = R.string.loading_error), modifier = Modifier.clickable(onClick = retry))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此微件使用起来也很简单直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> LoadingContent(</span><br><span class="line">     modifier = Modifier.align(CenterHorizontally) ,</span><br><span class="line">     loader = (vm.sponsorService::getAllSponsor) </span><br><span class="line"> ) &#123; list -&gt;</span><br><span class="line">     list?.let&#123;</span><br><span class="line">         Column &#123;</span><br><span class="line">             SponsorList(it)</span><br><span class="line">             Text(&quot;加载完成&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码在这里：<br>加载微件：<a href="https://github.com/FunnySaltyFish/FunnyTranslation/blob/compose/translate/src/main/java/com/funny/translation/translate/ui/widget/LoadingWidget.kt">FunnyTranslation/LoadingWidget.kt</a><br>使用示例：<a href="https://github.com/FunnySaltyFish/FunnyTranslation/blob/d747a153a8ec0ed4c14ad9b2156f93aac1401380/translate/src/main/java/com/funny/translation/translate/ui/thanks/ThanksScreen.kt">FunnyTranslation/ThanksScreen.kt</a></p><p>这只是一个简单方案，由衷欢迎各位探讨。  </p><p>最后再自荐一下我的开源项目（就是上面那个链接），Jetpack Compose实现的翻译软件。不妨点个star，万一什么地方有用呢（逃~</p><p>参考资料：<br><a href="https://juejin.cn/post/7010382907084636168">【开源项目】简单易用的Compose版StateLayout,了解一下~ - 掘金 (juejin.cn)</a></p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>在于掘金用户@<a href="https://juejin.cn/user/3491704662136541">Petterp</a> 探讨后，他给出了一个可定制化程度更高、适用范围更广的实现。大家可以参见：<a href="https://juejin.cn/post/7042110419439190024">链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;加载数据在Android开发中应该算是非常频繁的操作了，因此简单在Jetpack Compose中实现一个通用的加载微件&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载中（转圈圈）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;加</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>基于Jetpack Compose打造一款翻译APP</title>
    <link href="https://blog.funnysaltyfish.fun/2021/11/11/jetpack-compose-funny-trans/"/>
    <id>https://blog.funnysaltyfish.fun/2021/11/11/jetpack-compose-funny-trans/</id>
    <published>2021-11-11T15:18:35.000Z</published>
    <updated>2022-03-28T02:37:06.945Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="https://www.coolapk.com/apk/com.funny.translation">FunnyTranslation</a> 是基于Jetpack Compose写成的翻译软件。<strong>它首先是个可以用的软件，其次也是个开源项目。</strong></p><p>开源地址：<a href="https://github.com/FunnySaltyFish/FunnyTranslation">FunnySaltyFish/FunnyTranslation: 基于Jetpack Compose开发的翻译软件，支持多引擎、插件化~ | Jetpack Compose+MVVM+协程+Room (github.com)</a></p><h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><table><thead><tr><th>图片</th><th>图片</th></tr></thead><tbody><tr><td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202111102032441.jpg" alt="Screenshot_2021-11-07-22-37-33-814_com.funny.tran" style="zoom:33%;" /></td><td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202111102032313.jpg" alt="Screenshot_2021-11-07-22-39-18-201_com.funny.tran" style="zoom:33%;" /></td></tr><tr><td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202111102033517.jpg" alt="Screenshot_2021-11-07-22-40-16-339_com.funny.tran" style="zoom:33%;" /></td><td><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202111102033976.jpg" alt="IMG_20211107_223720" style="zoom:33%;" /></td></tr></tbody></table><p>上面截图显示的所有UI都是基于Jetpack Compose搭建的</p><h4 id="挑点啥说一说"><a href="#挑点啥说一说" class="headerlink" title="挑点啥说一说"></a>挑点啥说一说</h4><p>项目开始时觉得没什么，但是真的写起来却发现不少坑。下面简单挑一个例子。</p><h5 id="导航栏内容与底部同步"><a href="#导航栏内容与底部同步" class="headerlink" title="导航栏内容与底部同步"></a>导航栏内容与底部同步</h5><p>软件的导航栏是基于Row自己定义的，摘录部分如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExperimentalAnimationApi</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomNavigation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    screens : <span class="type">Array</span>&lt;<span class="type">TranslateScreen</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    currentScreen: <span class="type">TranslateScreen</span> = screens[<span class="number">0</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">    onItemClick: (<span class="type">TranslateScreen</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Row(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .background(MaterialTheme.colors.background)</span><br><span class="line">            .padding(start=<span class="number">8.</span>dp,end=<span class="number">8.</span>dp,bottom = <span class="number">4.</span>dp,top = <span class="number">2.</span>dp)</span><br><span class="line">            .fillMaxWidth(),</span><br><span class="line">        verticalAlignment = Alignment.CenterVertically,</span><br><span class="line">        horizontalArrangement = Arrangement.SpaceAround</span><br><span class="line">    ) &#123;</span><br><span class="line">        screens.forEach&#123; screen-&gt;</span><br><span class="line">            CustomNavigationItem(item = screen, isSelected = currentScreen==screen) &#123;</span><br><span class="line">                onItemClick(screen)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI实现并不复杂，问题在于用它导航的时候</p><p>首先是点击Icon跳转到对应页面，这一部分<strong>理论上</strong>并不复杂，用<code>navController.navigate(screen.route)</code>就能达到最简单的效果</p><p>然后第一个问题出现了：每次进行navigate的时候，都会重新创建对应的Screen，导致之前页面输入的内容啥的都会被清空；而且每一次点开对应页面就会有一个新的，导致返回的时候需要疯狂点击回退，在不同页面间反复横跳……这肯定不行</p><p>怎么办呢？参考官方文档，说是加上<code>launchSingleTop=true</code>即可，也就是改成下面这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navController.navigate(screen.route)&#123;</span><br><span class="line">    launchSingleTop = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后……然后居然还是不行！我不得其解，终于在过了几天后找到了有效的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navController.navigate(screen.route)&#123;</span><br><span class="line">    <span class="comment">//当底部导航导航到在非首页的页面时，执行手机的返回键 回到首页</span></span><br><span class="line">    popUpTo(navController.graph.startDestinationId)&#123;</span><br><span class="line">        saveState = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从名字就能看出来 跟activity的启动模式中的SingleTop模式一样 避免在栈顶创建多个实例</span></span><br><span class="line">    launchSingleTop = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//切换状态的时候保存页面状态</span></span><br><span class="line">    restoreState = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这应该是从一篇博客上看到的，具体哪篇现在也找不到了。在此表示感谢！</p><p>上面的问题解决了，新的问题又来了：点击返回键时，导航栏也应该跟着变动，回到主页面。这一部分的需求又该怎么实现呢？</p><p>最终在开源项目里面一顿乱翻，终于找到了一个解决方案：在<code>NavController.OnDestinationChangedListener</code>回调中使用<code>hierarchy</code>进行匹配，让页面内容与底部导航栏始终保持同步。相关代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> selectedItem = remember &#123; mutableStateOf&lt;TranslateScreen&gt;(TranslateScreen.MainScreen) &#125;</span><br><span class="line"></span><br><span class="line">   DisposableEffect(<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">val</span> listener = NavController.OnDestinationChangedListener &#123; _, destination, _ -&gt;</span><br><span class="line">           <span class="keyword">when</span> &#123;</span><br><span class="line">               destination.hierarchy.any &#123; it.route == TranslateScreen.MainScreen.route &#125; -&gt; &#123;</span><br><span class="line">                   selectedItem.value = TranslateScreen.MainScreen</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// ...省略类似的几个</span></span><br><span class="line">               destination.hierarchy.any &#123; it.route == TranslateScreen.ThanksScreen.route &#125; -&gt; &#123;</span><br><span class="line">                   selectedItem.value = TranslateScreen.ThanksScreen</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addOnDestinationChangedListener(listener)</span><br><span class="line"></span><br><span class="line">       onDispose &#123;</span><br><span class="line">           removeOnDestinationChangedListener(listener)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>顺便用<code>BackHandler</code>实现了退出时二次确认：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BackHandler(enabled = <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (navController.previousBackStackEntry == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> curTime = System.currentTimeMillis()</span><br><span class="line">            <span class="keyword">if</span>(curTime - activityVM.lastBackTime &gt; <span class="number">2000</span>)&#123;</span><br><span class="line">                scope.launch &#123; scaffoldState.snackbarHostState.showSnackbar(FunnyApplication.resources.getString(R.string.snack_quit)) &#125;</span><br><span class="line">                activityVM.lastBackTime = curTime</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                exitAppAction()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;AppNavigation: back&quot;</span>)</span><br><span class="line">            <span class="comment">//currentScreen = TranslateScreen.MainScreen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这部分完整代码在这：<a href="https://github.com/FunnySaltyFish/FunnyTranslation/blob/compose/translate/src/main/java/com/funny/translation/translate/TransActivity.kt">FunnyTranslation/TransActivity.kt at compose · FunnySaltyFish/FunnyTranslation (github.com)</a></p><p>这样类似的地方在应用开发时还有很多，我相信这里的各位能有同感，就不在这搞吐槽大会了。不过既然尝试了一门新技术，就得做好万事碰壁自己探索的准备。这样也才有点Coder的精神嘛~</p><h4 id="然后呢"><a href="#然后呢" class="headerlink" title="然后呢"></a>然后呢</h4><p>应用目前还在完善，但基本功能确实可以用了，希望各位不吝赐教。</p><p>我在写的时候感觉很多小需求很少有中文资料做整理的，于是自己开了个<a href="https://juejin.cn/column/7024350372680433672">专栏</a>，希望能把这些记录下来，供后来者参阅。</p><p>代码现在有些地方写的不太合理，比如加载数据的部分，确实还需要进一步修改。欢迎参与贡献！</p><p>最后再复读一遍地址：<a href="https://github.com/FunnySaltyFish/FunnyTranslation">https://github.com/FunnySaltyFish/FunnyTranslation</a></p><p>如果觉得项目有用的话，欢迎star~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.coolapk.com/apk/com.funny.translation&quot;&gt;FunnyTrans</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 输入法的弹出与隐藏</title>
    <link href="https://blog.funnysaltyfish.fun/2021/10/29/jetpack-compose-soft-keyboard/"/>
    <id>https://blog.funnysaltyfish.fun/2021/10/29/jetpack-compose-soft-keyboard/</id>
    <published>2021-10-29T05:14:43.000Z</published>
    <updated>2021-10-29T05:15:45.574Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文基于Jetpack Compose1.0.4</em></p><p>Jetpack Compose 提供了 <code>SoftwareKeyboardController</code>用于控制软键盘的显示与隐藏，可在Composable中通过<code>LocalSoftwareKeyboardController.current</code>获取</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> keyboard = LocalSoftwareKeyboardController.current</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">onClick = &#123;</span><br><span class="line">    keyboard?.hide()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作会试图关闭软键盘，如果因为各种原因软键盘暂时无法关闭，则此操作会被忽略</p><h4 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h4><p>打开软键盘涉及到焦点的获取</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码均在 @Composable 函数中</span></span><br><span class="line"><span class="comment">// 焦点请求器</span></span><br><span class="line"><span class="keyword">val</span> focusRequester = remember &#123;</span><br><span class="line">    FocusRequester()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为需要获取焦点的TextField添加此Modifier</span></span><br><span class="line">BasicTextField(</span><br><span class="line">    modifier = Modifier</span><br><span class="line">        .fillMaxWidth()</span><br><span class="line">        .focusRequester(focusRequester)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 请求焦点</span></span><br><span class="line">Button(onClick = &#123;</span><br><span class="line">    focusRequester.requestFocus()</span><br><span class="line">    keyboard?.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该操作会试图打开软键盘，如果因为各种原因软键盘暂时无法被打开，则此操作会被忽略</p><h3 id="关于此系列"><a href="#关于此系列" class="headerlink" title="关于此系列"></a>关于此系列</h3><p>此系列<strong>并非完整的系列教程，仅针对Jetpack Compose使用中的具体场景给出对应最小化代码</strong>。目前Jetpack Compose中文资料非常少，希望我能在这方面做出自己的贡献。</p><ul><li>如果要参阅完整项目，可以看我开源的</li></ul><p><a href="https://github.com/FunnySaltyFish/FunnyTranslation/">FunnySaltyFish/FunnyTranslation: 基于Jetpack Compose开发的翻译软件，支持多引擎、插件化~ | Jetpack Compose+MVVM+协程+Room (github.com)</a></p><ul><li>获取系列最新更新：<a href="https://funnysaltyfish.github.io/">FunnySaltyFish’s Blog - FunnySaltyFish的小站</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;本文基于Jetpack Compose1.0.4&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Jetpack Compose 提供了 &lt;code&gt;SoftwareKeyboardController&lt;/code&gt;用于控制软键盘的显示与隐藏，可在Composable中通过&lt;code&gt;Lo</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
  <entry>
    <title>我们开启爱发电啦</title>
    <link href="https://blog.funnysaltyfish.fun/2021/10/27/start-aifadian/"/>
    <id>https://blog.funnysaltyfish.fun/2021/10/27/start-aifadian/</id>
    <published>2021-10-27T13:28:15.000Z</published>
    <updated>2021-10-27T13:33:59.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发电"><a href="#发电" class="headerlink" title="发电"></a>发电</h2><p>为了支持项目更好地发展，自2021年10月27日起，FunnyTranslation启动爱发电。你可以在<a href="https://afdian.net/@funnysaltyfish?tab=home">这里</a>为项目出一份力！</p><p>感谢各位小伙伴的支持！你的每一次发电都会被应用永远记录！</p><h2 id="爱你，Mua"><a href="#爱你，Mua" class="headerlink" title="爱你，Mua~"></a>爱你，Mua~</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;发电&quot;&gt;&lt;a href=&quot;#发电&quot; class=&quot;headerlink&quot; title=&quot;发电&quot;&gt;&lt;/a&gt;发电&lt;/h2&gt;&lt;p&gt;为了支持项目更好地发展，自2021年10月27日起，FunnyTranslation启动爱发电。你可以在&lt;a href=&quot;https://a</summary>
      
    
    
    
    
    <category term="其他" scheme="https://blog.funnysaltyfish.fun/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>在win11安装WSA并直接调试App</title>
    <link href="https://blog.funnysaltyfish.fun/2021/10/21/win11-wsa-explore/"/>
    <id>https://blog.funnysaltyfish.fun/2021/10/21/win11-wsa-explore/</id>
    <published>2021-10-21T09:38:48.000Z</published>
    <updated>2022-03-28T02:37:06.940Z</updated>
    
    <content type="html"><![CDATA[<p>2021年10月20日，微软”千呼万唤始出来“地发布了对WSA的初步支持，win11具备了原生运行android apk的能力</p><p>废话之前，先上图</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211723184.png"></p><p>此窗口可正常拖动、缩放大小，在任务栏独立显示</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211724861.png"></p><p>目前（2021年10月21日）该功能还是预览阶段。</p><p>话不多说，开搞</p><h3 id="安装WSA"><a href="#安装WSA" class="headerlink" title="安装WSA"></a>安装WSA</h3><p><strong>此部分整理自酷安，在此感谢各位大佬</strong></p><p>首先需要确保你的计算机是<strong>win11</strong>最新版本且处于<strong>beta</strong>预览通道</p><ol><li>打开WSA 微软商店链接： <a href="https://www.microsoft.com/store/productId/9P3395VX91NR">这里</a></li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211724051.png"></p><p>目前仅有美区支持，故选择确定</p><p>登录微软账号后获取子应用并安装</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725505.png"></p><ol start="2"><li>复制打开后的的链接，到 <a href="https://store.rg-adguard.net/">安装包抓包网址</a> 输入上述商店链接，右边要选择<strong>Slow</strong>通道</li></ol><p>(选择Slow通道是因为目前仅有Beta有)</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725673.png" alt="image-20211021160930124"></p><ol start="3"><li>找到最下面名为<br>“MicrosoftCorporationII.WindowsSubsystemForAndroid_***_msixbundle” 的包进行下载</li></ol><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725898.png" alt="image-20211021161024423"></p><ol start="4"><li>下载完毕后以<strong>管理员身份</strong>运行powershell，输入命令安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-appxpackage d:\...(刚刚下载文件的路径)</span><br></pre></td></tr></table></figure><p>这时候进度条可能不会变化，耐心等待即可</p><ul><li>如果安装有问题：缺少框架，在上述页面下载Microsoft.UI.Xaml.2.6_2.62108.18004.0_x64__8wekyb3d8bbwe.BlockMap，进行命令行安装</li></ul><ol start="5"><li><p>在菜单栏找到刚刚安装的Windows SubSystem for Android，打开</p></li><li><p>点击右上角的图标，选择刚刚下载的文件</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725630.png"></p></li></ol><ul><li><p>如果说未虚拟化，在<code>设置-应用-可选功能-更多windows功能</code> 开启 <strong>虚拟机平台</strong>并重启</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725774.png" alt="image-20211021161623272"></p></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725363.png" alt="image-20211021161651293"></p><p>然后就可以打开这个子系统了</p><h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><p>打开刚刚安装的Windows Subsystem for Android，开启开发人员模式并刷新下面的ip地址</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725181.png"></p><p>打开cmd，使用adb连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:58526</span><br></pre></td></tr></table></figure><p>这个ip是上面显示出来的ip</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/Snipaste_2021-10-21_15-34-38.png"></p><p>连接成功后，就可以用adb安装软件了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install APK路径</span><br></pre></td></tr></table></figure><p>安装完后可以在菜单看见安装的应用</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725576.png" alt="image-20211021162540434"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>都连接到ADB了，打开Android Studio就能调试了</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725493.png"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种方式有几个缺点</p><ul><li>应用dpi和窗口大小比较奇怪</li><li>Android系统为11，如果你需要Android12的适配还是得模拟器</li><li>功能上不如AS自带的模拟器全</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>当然也有优点</p><ul><li><p>占用内存小</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://web.funnysaltyfish.fun/temp_img/202110211725987.png"></p></li><li><p>更流畅</p></li><li><p>无需额外模拟器</p></li><li><p>可自由拉伸窗口，检测屏幕适配情况</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021年10月20日，微软”千呼万唤始出来“地发布了对WSA的初步支持，win11具备了原生运行android apk的能力&lt;/p&gt;
&lt;p&gt;废话之前，先上图&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R0lGODdhAQABAPAAA</summary>
      
    
    
    
    
    <category term="探索" scheme="https://blog.funnysaltyfish.fun/tags/%E6%8E%A2%E7%B4%A2/"/>
    
    <category term="Android" scheme="https://blog.funnysaltyfish.fun/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Python3.10稳定版特性速览</title>
    <link href="https://blog.funnysaltyfish.fun/2021/10/05/python-3-10-taste/"/>
    <id>https://blog.funnysaltyfish.fun/2021/10/05/python-3-10-taste/</id>
    <published>2021-10-05T14:25:59.000Z</published>
    <updated>2021-10-05T14:30:00.029Z</updated>
    
    <content type="html"><![CDATA[<p>Python 3.10正式发布，你尝鲜了吗？</p><blockquote><p>本文参考自 Python官方文档 ： <a href="https://www.python.org/downloads/release/python-3100/">Python Release Python 3.10.0 | Python.org</a></p></blockquote><p>在正值国庆假期人山人海的2021年10月4号，Python官方<a href="https://www.python.org/downloads/release/python-3100/">正式发布了Python3.10.0</a>。作为一只假期期间宅着不动的coding人，自然是第一时间体验了一波。相较于之前的版本，该版本有以下主要变更。</p><h3 id="新的-Union-Type表达"><a href="#新的-Union-Type表达" class="headerlink" title="新的 Union Type表达"></a>新的 Union Type表达</h3><p>新版本简化了 Union Type 的使用 ，改为更为简洁的<code>|</code> </p><p>旧版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line">a: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>新的版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: <span class="built_in">str</span> | <span class="built_in">int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>二者完全等价：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>] == <span class="built_in">int</span> | <span class="built_in">str</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>这类变化在其他地方也相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 旧版:</span></span><br><span class="line"><span class="comment"># def f(list: List[Union[int, str]], param: Optional[int]) -&gt; Union[float, str]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params"><span class="built_in">list</span>: <span class="type">List</span>[<span class="built_in">int</span> | <span class="built_in">str</span>], param: <span class="built_in">int</span> | <span class="literal">None</span></span>) -&gt; <span class="built_in">float</span> | <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f([<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>], <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧版： </span></span><br><span class="line"><span class="comment"># typing.List[typing.Union[str, int]]</span></span><br><span class="line">typing.<span class="type">List</span>[<span class="built_in">str</span> | <span class="built_in">int</span>]</span><br><span class="line"><span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧版： </span></span><br><span class="line"><span class="comment"># typing.Dict[str, typing.Union[int, float]]</span></span><br><span class="line">typing.<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span> | <span class="built_in">float</span>]</span><br><span class="line"><span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span> | <span class="built_in">float</span>]</span><br></pre></td></tr></table></figure><p>该特性也可用于 <code>isinstance</code>和<code>issubclass</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">isinstance</span>(<span class="string">&quot;FunnySaltyFish&quot;</span>, <span class="built_in">int</span>|<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># True </span></span><br><span class="line"><span class="built_in">issubclass</span>(<span class="built_in">str</span>, <span class="built_in">str</span>|<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><h3 id="zip-可选严格模式"><a href="#zip-可选严格模式" class="headerlink" title="zip 可选严格模式"></a>zip 可选严格模式</h3><p>zip新增可选参数<code>strict</code>， 当该选项为True时，传入zip的两个可迭代项长度必须相等，否则将抛出 <code>ValueError</code></p><p>旧版（及不加此参数），当二者长度不等时，以长度较小的为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>]</span><br><span class="line">numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">z = <span class="built_in">zip</span>(names,numbers)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> z:</span><br><span class="line">    <span class="built_in">print</span>(each)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># (&#x27;a&#x27;, 1)</span></span><br><span class="line"><span class="comment"># (&#x27;b&#x27;, 2)</span></span><br><span class="line"><span class="comment"># (&#x27;c&#x27;, 3)</span></span><br></pre></td></tr></table></figure><p>设置strict为True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">z = <span class="built_in">zip</span>(names,numbers,strict=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">d:\projects\python\learn\Py310探索.py <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      <span class="number">3</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">      <span class="number">4</span> z = <span class="built_in">zip</span>(names,numbers,strict=<span class="literal">True</span>)</span><br><span class="line">----&gt; <span class="number">5</span> <span class="keyword">for</span> each <span class="keyword">in</span> z:</span><br><span class="line">      <span class="number">6</span>     <span class="built_in">print</span>(each)</span><br><span class="line"></span><br><span class="line">ValueError: <span class="built_in">zip</span>() argument <span class="number">2</span> <span class="keyword">is</span> shorter than argument <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="带括号的上下文管理器"><a href="#带括号的上下文管理器" class="headerlink" title="带括号的上下文管理器"></a>带括号的上下文管理器</h3><p>with可以加括号了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (CtxManager() <span class="keyword">as</span> example):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (</span><br><span class="line">    CtxManager1(),</span><br><span class="line">    CtxManager2()</span><br><span class="line">):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (CtxManager1() <span class="keyword">as</span> example,</span><br><span class="line">      CtxManager2()):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (CtxManager1(),</span><br><span class="line">      CtxManager2() <span class="keyword">as</span> example):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (</span><br><span class="line">    CtxManager1() <span class="keyword">as</span> example1,</span><br><span class="line">    CtxManager2() <span class="keyword">as</span> example2</span><br><span class="line">):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line">p = pathlib.Path()</span><br><span class="line">p1 = p/<span class="string">&quot;text1.txt&quot;</span> <span class="comment"># 内容：文本1的内容</span></span><br><span class="line">p2 = p/<span class="string">&quot;text2.txt&quot;</span> <span class="comment"># 内容：文本2的内容</span></span><br><span class="line"><span class="keyword">with</span>(</span><br><span class="line">    p1.<span class="built_in">open</span>(encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f1,</span><br><span class="line">    p2.<span class="built_in">open</span>(encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f2</span><br><span class="line">):</span><br><span class="line">    <span class="built_in">print</span>(f1.read(), f2.read(), sep=<span class="string">&quot;\n&quot;</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 文本1的内容</span></span><br><span class="line">    <span class="comment"># 文本2的内容</span></span><br></pre></td></tr></table></figure><h3 id="显式类型别名"><a href="#显式类型别名" class="headerlink" title="显式类型别名"></a>显式类型别名</h3><p>使用 TypeAlias 显式标注类型别名，提高可读性</p><p>旧的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus_int</span>(<span class="params">a:x,b:x</span>) -&gt; x:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><p>可以看到，x很容易被搞混</p><p>新的方式：使用 TypeAlias表明这是个别名 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeAlias</span><br><span class="line">x : TypeAlias = <span class="built_in">int</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus_int</span>(<span class="params">a:x,b:x</span>) -&gt; x:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><h3 id="match…case语句"><a href="#match…case语句" class="headerlink" title="match…case语句"></a>match…case语句</h3><p>对，就是其他语言的<code>switch-case</code>，python终于提供了支持，还是加强版的</p><p>完整语法参见：<a href="https://www.python.org/dev/peps/pep-0634/#id25">PEP 634 – Structural Pattern Matching: Specification | Python.org</a></p><p>举几个例子：</p><p>基本的类型匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">day = <span class="number">6</span></span><br><span class="line">match day:</span><br><span class="line">    case <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;星期一&quot;</span>)</span><br><span class="line">    case <span class="number">6</span> | <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;周末&quot;</span>)</span><br><span class="line">    case _ : </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;其他情况&quot;</span>)</span><br></pre></td></tr></table></figure><p>subject：这在处理命令行参数的时候特别有用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @copyright : [FunnySaltyFish](https://funnysaltyfish.github.io)</span></span><br><span class="line"><span class="string">    @date : 2021/10/05 21:08:42</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">command = <span class="string">&quot;save 1.txt&quot;</span></span><br><span class="line"><span class="comment"># 试着把command改成 list / copy 1.txt 2.txt 看看效果</span></span><br><span class="line">match command.split(<span class="string">&quot; &quot;</span>):</span><br><span class="line">    case [<span class="string">&quot;list&quot;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;列出文件~&quot;</span>)</span><br><span class="line">    case [<span class="string">&quot;save&quot;</span>, file_name]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;保存文件到 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line">    case [<span class="string">&quot;copy&quot;</span>,source,target]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;拷贝 <span class="subst">&#123;source&#125;</span> -&gt; <span class="subst">&#123;target&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以匹配对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">id</span>: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">a = Student(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># a = Student(2)</span></span><br><span class="line"><span class="comment"># a = Teacher(&quot;FunnySaltyFish&quot;)</span></span><br><span class="line">match a:</span><br><span class="line">    case Student(<span class="built_in">id</span> = <span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;这是位学生，且id正好是2&quot;</span>)</span><br><span class="line">    case Student():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;这是学生，id为<span class="subst">&#123;a.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line">    case Teacher():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;这是老师, 姓名为<span class="subst">&#123;a.name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然也可以匹配字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;李四&quot;</span>, <span class="comment"># 张三</span></span><br><span class="line">    <span class="string">&quot;age&quot;</span> : <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;hobby&quot;</span> : <span class="string">&quot;阅读&quot;</span></span><br><span class="line">&#125; </span><br><span class="line">match d:</span><br><span class="line">    case &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>, **args&#125;:</span><br><span class="line">        <span class="comment"># **收集其他参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是张三&quot;</span>, args) <span class="comment"># 这是张三 &#123;&#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;阅读&#x27;&#125;</span></span><br><span class="line">    case &#123;<span class="string">&quot;name&quot;</span> : name , <span class="string">&quot;age&quot;</span> : age, <span class="string">&quot;hobby&quot;</span>: hobby&#125;:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我叫<span class="subst">&#123;name&#125;</span>, 今年<span class="subst">&#123;age&#125;</span>岁, 喜欢<span class="subst">&#123;hobby&#125;</span>&quot;</span>) <span class="comment">#我叫李四,今年18岁，喜欢阅读</span></span><br></pre></td></tr></table></figure><p>更复杂的还有结合Guard、匹配捕获等使用，具体可以参见：<a href="https://www.python.org/dev/peps/pep-0635/#id15">PEP 635 – Structural Pattern Matching: Motivation and Rationale | Python.org</a> 和 <a href="https://www.python.org/dev/peps/pep-0636/">PEP 636 – Structural Pattern Matching: Tutorial | Python.org</a></p><h3 id="更友好的报错提示"><a href="#更友好的报错提示" class="headerlink" title="更友好的报错提示"></a>更友好的报错提示</h3><p>现在，当你的括号、引号未闭合时，python会抛出更加清晰明了的错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;未闭合的str</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">File &quot;</span>d:\projects\python\learn\Py310探索.py<span class="string">&quot;, line 90</span></span><br><span class="line"><span class="string">    str = &quot;</span>未闭合的<span class="built_in">str</span></span><br><span class="line">          ^</span><br><span class="line">SyntaxError: unterminated string literal (detected at line <span class="number">90</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">  File <span class="string">&quot;d:\projects\python\learn\Py310探索.py&quot;</span>, line <span class="number">91</span></span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">          ^</span><br><span class="line">SyntaxError: <span class="string">&#x27;[&#x27;</span> was never closed</span><br></pre></td></tr></table></figure><h3 id="其他一些更新："><a href="#其他一些更新：" class="headerlink" title="其他一些更新："></a>其他一些更新：</h3><h4 id="distutils-被弃用"><a href="#distutils-被弃用" class="headerlink" title="distutils 被弃用"></a>distutils 被弃用</h4><p>推荐使用 setuptools</p><h4 id="需要-OpenSSL-1-1-1-及以上版本"><a href="#需要-OpenSSL-1-1-1-及以上版本" class="headerlink" title="需要  OpenSSL 1.1.1 及以上版本"></a>需要  OpenSSL 1.1.1 及以上版本</h4><h4 id="移除-Py-UNICODE编码API"><a href="#移除-Py-UNICODE编码API" class="headerlink" title="移除 Py_UNICODE编码API"></a>移除 Py_UNICODE编码API</h4><h4 id="PyUnicodeObject的wstr被弃用，并将在之后移除"><a href="#PyUnicodeObject的wstr被弃用，并将在之后移除" class="headerlink" title="PyUnicodeObject的wstr被弃用，并将在之后移除"></a>PyUnicodeObject的wstr被弃用，并将在之后移除</h4><p>完。摸鱼去了。</p><blockquote><p>作者：FunnySaltyFish<br>主页：<a href="https://funnysaltyfish.github.io/">https://funnysaltyfish.github.io/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python 3.10正式发布，你尝鲜了吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文参考自 Python官方文档 ： &lt;a href=&quot;https://www.python.org/downloads/release/python-3100/&quot;&gt;Python Rele</summary>
      
    
    
    
    
    <category term="Python" scheme="https://blog.funnysaltyfish.fun/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Jitpack.io ERROR No build artifacts found一路踩坑的解决【Gradle 7.0+,Kotlin 1.5+】</title>
    <link href="https://blog.funnysaltyfish.fun/2021/07/26/jitpack-build-error-solve/"/>
    <id>https://blog.funnysaltyfish.fun/2021/07/26/jitpack-build-error-solve/</id>
    <published>2021-07-26T10:15:04.000Z</published>
    <updated>2021-07-26T10:18:57.942Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间上传我的项目<a href="https://github.com/FunnySaltyFish/CMaterialColors/">CMaterialColors</a>到Jitpack时一直出现错误，最早报出的错误是：</p><blockquote><p>Found artifact: com.funny.cmaterialcolors:release:1.0.0<br>Found artifact: com.funny.cmaterialcolors:release:<br>2021-06-15T08:52:13.4704949Z<br>Exit code: 0<br>ERROR: No build artifacts found</p></blockquote><p>实话说当时非常无语，经过几次失败的尝试后我决定去看看完整的报错日志，然后发现了中间其实就有报错：</p><blockquote><p>An exception occurred applying plugin request [id: ‘com.android.application’]<br>Failed to apply plugin ‘com.android.internal.application’.<br>Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8.<br>     You can try some of the following options:<br>       - changing the IDE settings.<br>       - changing the JAVA_HOME environment variable.<br>       - changing <code>org.gradle.java.home</code> in <code>gradle.properties</code>.</p></blockquote><p>意思是要去修改默认的Java编译环境，查阅Jitpack官方英文<a href="https://github.com/jitpack/jitpack.io/blob/master/BUILDING.md">文档</a>，找到了如下解决措施：</p><blockquote><p>You can create a jitpack.yml file in the root of your repository and override the build commands:</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdk:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">openjdk9</span></span><br></pre></td></tr></table></figure><p>翻译成中文就是：</p><ul><li>在<strong>项目根目录</strong>创建文件<code>jitpack.yml</code></li><li>在里面添加上述文本即可指定编译用的Java版本</li></ul><p>于是，在解决完了这个问题后，我怀着信心满满的心情再次提交，而这一次……<br>然并卵，错误还是存在……</p><p>老实说这个错误真是非常迷惑的。我又尝试了一些方法，均未果。然后没办法，继续回去看文档呗。<br>我项目里面用的是<code>maven-publish</code>插件，官方文档说执行的命令是</p><blockquote><p>./gradlew build publishToMavenLocal</p></blockquote><p>然后在终端里面试了试，发现居然报错了！<br>然后又是按对应的报错改Bug，直到本地可以正常执行此命令<br>改完之后信心满满的提交，结果新的错误产生了……</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Could not resolve compiler classpath. Check <span class="keyword">if</span> Kotlin Gradle plugin repository is configured <span class="keyword">in</span> project <span class="string">&#x27;:app&#x27;</span>.</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Could not determine the dependencies of task <span class="string">&#x27;:app:compileReleaseKotlin&#x27;</span>.</span><br><span class="line">&gt; Could not resolve all files <span class="keyword">for</span> configuration <span class="string">&#x27;:app:kotlinCompilerClasspath&#x27;</span>.</span><br><span class="line">   &gt; Cannot resolve external dependency org.jetbrains.kotlin:kotlin-compiler-embeddable:1.5.10 because no repositories are defined.</span><br><span class="line">     Required by:</span><br><span class="line">         project :app</span><br></pre></td></tr></table></figure><p>我TM！！！<br>网上搜根本搜不到对应的解决措施，没办法一点点改呗。<br>又试了几次，还是不行。<br>这时想到了一个办法，我开始去翻Github，找与我的项目使用的依赖库相似的项目（kotlin 1.5，Gradle 7.0，Compose 1.0.0-rc01），然后对照它的项目文件一个个看。<br>最后找到了差异，我的<code>lib/build.gradle</code>里面少写了这一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// kotlin</span><br><span class="line">implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:<span class="variable">$kotlin_version</span>&quot;</span></span><br></pre></td></tr></table></figure><p>终于，在版本都累加到<code>1.0.21</code>后，我终终终终终于提交成功了！<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/9fdcfa0d460e44bea18538ff9999a8cf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTk2MDY3,size_16,color_FFFFFF,t_70#pic_center" alt="终于"></p><p>那一刻，真的，难以言表！！！</p><p>最后吐个槽，各位博主大大抄袭文章能不能有个限度，nm各个文章都在用着早已被废弃的插件，jdk11的问题都没得人指出。简直了。。。</p><p><strong>如果你需要参考对应文件，可以点击这个开源库：<a href="https://github.com/FunnySaltyFish/CMaterialColors/">CMaterialColors</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前段时间上传我的项目&lt;a href=&quot;https://github.com/FunnySaltyFish/CMaterialColors/&quot;&gt;CMaterialColors&lt;/a&gt;到Jitpack时一直出现错误，最早报出的错误是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;F</summary>
      
    
    
    
    
    <category term="Jitpack" scheme="https://blog.funnysaltyfish.fun/tags/Jitpack/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose异步加载图片的实现</title>
    <link href="https://blog.funnysaltyfish.fun/2021/07/14/jetpack-compose-sync-load-image/"/>
    <id>https://blog.funnysaltyfish.fun/2021/07/14/jetpack-compose-sync-load-image/</id>
    <published>2021-07-14T11:25:27.000Z</published>
    <updated>2021-07-14T11:29:52.771Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用两种方式，实现Compose中图片的异步加载</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android开发中异步加载图片是非常常见的需求。本文将带你实现这一需求。<br>本文将分为如下两个方面：</p><ol><li>自己写函数</li><li>用开源库</li></ol><hr><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="借助Glide库自己写"><a href="#借助Glide库自己写" class="headerlink" title="借助Glide库自己写"></a>借助Glide库自己写</h3><p>Glide开源库基本上成为了Android中加载图片的首选，其简单易用的API和强大的缓存能力让这一过程变得十分方便。<br>自然在Jetpack Compose中也可以使用。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在模块中的<code>build.gradle</code>中加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.github.bumptech.glide:glide:4.12.0&#x27;</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.github.bumptech.glide:compiler:4.12.0&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h4><p>如何让Glide把图片加载到Compose组件上去呢？我们可以利用其提供的<code>into(Target)</code>指定自定义的target，再搭配上<code>mutableState&lt;Bitmap&gt;</code>的返回值，即可实现在图片加载完成后Compose自动更新<br>图片加载时一般会有一个默认的<code>loading</code>图，我们可以如法炮制，让Glide先帮我们加载一张本地图片，然后再去加载网络图片即可。<br>编写的函数如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Glide库加载网络图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> [FunnySaltyFish](https://funnysaltyfish.github.io)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-07-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context Context 合理的Context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url String 加载的图片URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultImageId Int 默认加载的本地图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> MutableState&lt;Bitmap?&gt; 加载完成（失败为null）的Bitmap-State</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">Context</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    url: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@DrawableRes</span> defaultImageId: <span class="type">Int</span> = R.drawable.load_holder</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MutableState&lt;Bitmap?&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">&quot;LoadImage&quot;</span></span><br><span class="line">    <span class="keyword">val</span> bitmapState: MutableState&lt;Bitmap?&gt; = mutableStateOf(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为请求加上 Headers ，提高访问成功率</span></span><br><span class="line">    <span class="keyword">val</span> glideUrl = GlideUrl(url,LazyHeaders.Builder().addHeader(<span class="string">&quot;User-Agent&quot;</span>,<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edg/91.0.864.67&quot;</span>).build())</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先加载本地图片</span></span><br><span class="line">    Glide.with(context)</span><br><span class="line">        .asBitmap()</span><br><span class="line">        .load(defaultImageId)</span><br><span class="line">        .into(<span class="keyword">object</span> : CustomTarget&lt;Bitmap&gt;() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResourceReady</span><span class="params">(resource: <span class="type">Bitmap</span>, transition: <span class="type">Transition</span>&lt;<span class="type">in</span> <span class="type">Bitmap</span>&gt;?)</span></span> &#123;</span><br><span class="line">                <span class="comment">//自定义Target，在加载完成后将图片资源传递给bitmapState</span></span><br><span class="line">                bitmapState.value = resource</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoadCleared</span><span class="params">(placeholder: <span class="type">Drawable</span>?)</span></span> &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后再加载网络图片</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Glide.with(context)</span><br><span class="line">            .asBitmap()</span><br><span class="line">            .load(glideUrl)</span><br><span class="line">            .into(<span class="keyword">object</span> : CustomTarget&lt;Bitmap&gt;() &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResourceReady</span><span class="params">(resource: <span class="type">Bitmap</span>, transition: <span class="type">Transition</span>&lt;<span class="type">in</span> <span class="type">Bitmap</span>&gt;?)</span></span> &#123;</span><br><span class="line">                    <span class="comment">//自定义Target，在加载完成后将图片资源传递给bitmapState</span></span><br><span class="line">                    bitmapState.value = resource</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoadCleared</span><span class="params">(placeholder: <span class="type">Drawable</span>?)</span></span> &#123;&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (glideException: GlideException) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;loadImage: <span class="subst">$&#123;glideException.rootCauses&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bitmapState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h4><p>简单的例子如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoadPicture</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    url : <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> imageState = loadImage(</span><br><span class="line">        context = LocalContext.current,</span><br><span class="line">        url = url,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Card(modifier = Modifier</span><br><span class="line">        .padding(<span class="number">4.</span>dp)</span><br><span class="line">        .clickable &#123; &#125;) &#123;</span><br><span class="line">        <span class="comment">//如果图片加载成功</span></span><br><span class="line">        imageState.value?.let &#123;</span><br><span class="line">            Image(</span><br><span class="line">                bitmap = it.asImageBitmap(),</span><br><span class="line">                contentDescription = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                modifier = Modifier</span><br><span class="line">                    .padding(<span class="number">4.</span>dp)</span><br><span class="line">                    .fillMaxWidth()</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">LazyColumn &#123;</span><br><span class="line">    <span class="keyword">val</span> urls = arrayListOf&lt;String&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">500.</span><span class="number">.550</span>)&#123;urls.add(<span class="string">&quot;https://nyc3.digitaloceanspaces.com/food2fork/food2fork-static/featured_images/<span class="variable">$i</span>/featured_image.png&quot;</span>)&#125;</span><br><span class="line">    itemsIndexed(urls)&#123; _ , url -&gt; LoadPicture(url = url)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图所示：<br><strong>加载中</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210714190357323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTk2MDY3,size_16,color_FFFFFF,t_70#pic_center" alt="加载中"><br><strong>加载完毕</strong><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210714190734214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTk2MDY3,size_16,color_FFFFFF,t_70#pic_center" alt="加载成功"><br><code>P.S.：别忘了声明网络权限哦！</code></p><h3 id="借助开源框架"><a href="#借助开源框架" class="headerlink" title="借助开源框架"></a>借助开源框架</h3><p>事实上，谷歌在其<a href="https://developer.android.google.cn/jetpack/compose/libraries">开发文档</a>中也给出了示例，用的是开源库<a href="https://github.com/google/accompanist">Accompanist</a><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210714191039630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTk2MDY3,size_16,color_FFFFFF,t_70#pic_center" alt="谷歌的官方例子"><br>所以我们也可以用这个</p><h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;com.google.accompanist:accompanist-coil:0.13.0&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> [FunnySaltyFish](https://funnysaltyfish.github.io)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-07-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url 加载的链接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoadPicture2</span><span class="params">(url:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> painter = rememberCoilPainter(url)</span><br><span class="line"></span><br><span class="line">    Box &#123;</span><br><span class="line">        Image(</span><br><span class="line">            painter = painter,</span><br><span class="line">            contentDescription = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> (painter.loadState) &#123;</span><br><span class="line">            <span class="keyword">is</span> ImageLoadState.Loading -&gt; &#123;</span><br><span class="line">                <span class="comment">// 显示一个加载中的进度条</span></span><br><span class="line">                CircularProgressIndicator(Modifier.align(Alignment.Center))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> ImageLoadState.Error -&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果发生了什么错误，你可以在这里写</span></span><br><span class="line">                Text(text = <span class="string">&quot;发生错误&quot;</span>, color = MaterialColors.RedA200)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; Text(text = <span class="string">&quot;未知情况&quot;</span>, color = MaterialColors.PurpleA400)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210714191350243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTk2MDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210714191350753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTk2MDY3,size_16,color_FFFFFF,t_70#pic_center" alt="加载中"></p><p><code>P.S.：如果想更好的看到加载的情况，可以在模拟器设置中将网络类型设置为较慢的类型</code></p><h4 id="一些限制"><a href="#一些限制" class="headerlink" title="一些限制"></a>一些限制</h4><p>个人感觉，这种方式有以下的问题：</p><ul><li>滑动加载时不如Glide流畅</li><li>对Kotlin版本有要求，如（截止文章写作时）最新的<code>0.13.0</code>版就必须用<code>kotlin1.5</code>及以上版本，否则就会编译出错</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.youtube.com/watch?v=ktOWiLx83bQ&list=PLgCYzUzKIBE_I0_tU5TvkfQpnmrP_9XV8&index=20">视频</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文使用两种方式，实现Compose中图片的异步加载&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Android开发中异步加载图片是非常常见的需求。本文将带你实现这一需求</summary>
      
    
    
    
    
    <category term="Jetpack Compose" scheme="https://blog.funnysaltyfish.fun/tags/Jetpack-Compose/"/>
    
  </entry>
  
</feed>
